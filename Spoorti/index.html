<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Business  ideas</title>
<link rel="stylesheet" href="style1.css">
</head>
<body>
    
 <!--------------idea1--------->
 <div class="container">

    <img class="main-img" 
    src="img1.png.png"
    alt="Delivery Routing Image">

    <h2>Description</h2>
    <p style="text-align: justify;">
      A smart digital auction platform that supports real-time bidding, secure fish listing storage, 
      and automated winner selection using efficient data structures and algorithms.
    </p>

    <!-- ---------------- ALGORITHM 1 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 1: AVL Tree for Fish Listing Storage</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Stores fish listings in sorted order (type, weight, freshness, base price).</li>
            <li>Ensures fast search, insert, delete.</li>
            <li>Prevents duplicate listings and allows quick updates.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(log n)</b></li>
            <li>Space Complexity: <b>O(n)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('code1')">Show Algorithm Code</button>
        <button class="btn" onclick="runAVL()">Run Algorithm</button>
<div id="output-avl" class="output-card"></div>
        <div id="code1" class="code-box">
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include "json.hpp"
using json = nlohmann::json;
using namespace std;

struct Node {
    int price;
    string fishName;
    Node *left, *right;
    int height;
};

int height(Node* n) { return (n == nullptr ? 0 : n->height); }

Node* createNode(string name, int price) {
    Node* n = new Node();
    n->fishName = name;
    n->price = price;
    n->left = n->right = nullptr;
    n->height = 1;
    return n;
}

int getBalance(Node* n) { return (n ? height(n->left) - height(n->right) : 0); }

Node* rightRotate(Node* y) {
    Node* x = y->left;
    y->left = x->right;
    x->right = y;

    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;

    return x;
}

Node* leftRotate(Node* x) {
    Node* y = x->right;
    x->right = y->left;
    y->left = x;

    x->height = max(height(x->left), height(x->right)) + 1;
    y->height = max(height(y->left), height(y->right)) + 1;

    return y;
}

Node* insertNode(Node* root, string name, int price) {
    if (!root) return createNode(name, price);

    if (price < root->price)
        root->left = insertNode(root->left, name, price);
    else if (price > root->price)
        root->right = insertNode(root->right, name, price);
    else
        return root;

    root->height = 1 + max(height(root->left), height(root->right));

    int balance = getBalance(root);

    if (balance > 1 && price < root->left->price) return rightRotate(root);
    if (balance < -1 && price > root->right->price) return leftRotate(root);

    if (balance > 1 && price > root->left->price) {
        root->left = leftRotate(root->left);
        return rightRotate(root);
    }
    if (balance < -1 && price < root->right->price) {
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }
    return root;
}

void inorder(Node* root) {
    if (!root) return;
    inorder(root->left);
    cout << root->fishName << " â€” Rs." << root->price << endl;
    inorder(root->right);
}

int main() {
    ifstream file("fish_listings.json");
    json data;
    file >> data;

    Node* root = nullptr;

    for (auto &f : data["fish_listings"]) {
        root = insertNode(root, f["name"], f["price"]);
    }

    cout << "âœ” Fish List (AVL Inorder Sorted):\n";
    inorder(root);

    return 0;
}
        </div>
    </div>

    <!-- ---------------- ALGORITHM 2 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 2: Max Heap / Priority Queue for Live Bidding System</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Tracks highest bid instantly.</li>
            <li>Used during real-time bidding.</li>
            <li>Ensures buyers always see the highest valid bid.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: Insert: <b>O(log n)</b>, Get Max: <b>O(1)</b></li>
            <li>Space Complexity: <b>O(n)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('code2')">Show Algorithm Code</button>
        <button class="btn" onclick="runHeap()">Run Algorithm</button>
<div id="output-heap" class="output-card"></div>
        <div id="code2" class="code-box">
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;fstream&gt;
#include "json.hpp"
using json = nlohmann::json;
using namespace std;

struct Bid {
    int amount;
    string buyer;
};

struct CompareBid {
    bool operator()(Bid const& b1, Bid const& b2) {
        return b1.amount < b2.amount;
    }
};

priority_queue&lt;Bid, vector&lt;Bid&gt;, CompareBid&gt; bidHeap;

int main() {
    ifstream file("bids.json");
    json data;
    file >> data;

    for (auto &b : data["bids"]) {
        bidHeap.push({b["amount"], b["buyer"]});
    }

    cout << "âœ” Highest Current Bid:\n";
    Bid top = bidHeap.top();
    cout << "Buyer: " << top.buyer << " | Amount: Rs." << top.amount << endl;

    return 0;
}
        </div>
    </div>

    <!-- ---------------- ALGORITHM 3 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 3: Winner Selection (Heap pop)</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Automatically selects the highest valid bid.</li>
            <li>Removes it from heap and declares winner.</li>
            <li>Ensures fair, transparent auction results.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(log n)</b></li>
            <li>Space Complexity: <b>O(n)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('code3')">Show Algorithm Code</button>
        <button class="btn" onclick="runWinner()">Run Algorithm</button>
<div id="output-winner" class="output-card"></div>
        <div id="code3" class="code-box">
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;fstream&gt;
#include "json.hpp"
using json = nlohmann::json;
using namespace std;

struct Bid {
    int amount;
    string buyer;
};

struct CompareBid {
    bool operator()(Bid const& b1, Bid const& b2) {
        return b1.amount < b2.amount;
    }
};

priority_queue&lt;Bid, vector&lt;Bid&gt;, CompareBid&gt; bidHeap;

int main() {
    ifstream file("bids.json");
    json data;
    file >> data;

    for (auto &b : data["bids"]) {
        bidHeap.push({b["amount"], b["buyer"]});
    }

    if (bidHeap.empty()) {
        cout << "No bids found.\n";
        return 0;
    }

    Bid winner = bidHeap.top();
    bidHeap.pop();

    cout << "ðŸ† WINNER DECLARED ðŸ†\n";
    cout << "Buyer: " << winner.buyer << endl;
    cout << "Winning Bid: Rs." << winner.amount << endl;

    return 0;
}
        </div>
    </div>

</div>





 <!--------------idea2--------->
 <div class="container">

    

    <img class="main-img" 
        src="img2.png.jpg"
        alt="Eco Tourism Image">

    <h2>Description</h2>
    <p style="text-align: justify;">
        The Eco-Tourism Route Optimization App helps tourists in Trangapur 
        explore the best attractions through smart, personalized route planning. 
        Users select their interestsâ€”beaches, waterfalls, temples, or nature trailsâ€”and 
        the app calculates the most efficient travel path using real-time data. This provides
        tourists with a smoother, time-saving travel 
        experience while promoting sustainable and well-managed tourism.
    </p>

    <!-- ---------------- ALGORITHM 1 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 1: AVL Tree for Eco-Location Storage</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Stores eco-attractions in sorted order (location name, entry fee, distance, eco-rank).</li>
            <li>Ensures fast search, insert, delete.</li>
            <li>Handles large datasets of national parks, forest trails, lakes, viewpoints, etc.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(log n)</b></li>
            <li>Space Complexity: <b>O(n)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('code4')">Show Algorithm Code</button>&nbsp &nbsp
  <button class="btn" onclick="runAVL2()">Run Algorithm</button>
<div id="output-avl2" class="output-card"></div>
        <div id="code4" class="code-box">
<pre><code>
#include <iostream>
#include <fstream>
#include "json.hpp"
using json = nlohmann::json;
using namespace std;

struct Node {
    int ecoRank;
    string locationName;
    Node *left, *right;
    int height;
};

int height(Node* n){ return n ? n->height : 0; }

Node* createNode(string name, int rank){
    Node* n = new Node{name, rank, nullptr, nullptr, 1};
    return n;
}

int getBalance(Node* n){
    return n ? height(n->left) - height(n->right) : 0;
}

Node* rightRotate(Node* y){
    Node* x = y->left;
    Node* T2 = x->right;

    x->right = y;
    y->left = T2;

    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;

    return x;
}

Node* leftRotate(Node* x){
    Node* y = x->right;
    Node* T2 = y->left;

    y->left = x;
    x->right = T2;

    x->height = max(height(x->left), height(x->right)) + 1;
    y->height = max(height(y->left), height(y->right)) + 1;

    return y;
}

Node* insertNode(Node* root, string name, int ecoRank){
    if(!root) return createNode(name, ecoRank);

    if(ecoRank < root->ecoRank)
        root->left = insertNode(root->left, name, ecoRank);
    else if(ecoRank > root->ecoRank)
        root->right = insertNode(root->right, name, ecoRank);
    else
        return root;

    root->height = 1 + max(height(root->left), height(root->right));
    int balance = getBalance(root);

    if(balance > 1 && ecoRank < root->left->ecoRank)
        return rightRotate(root);

    if(balance < -1 && ecoRank > root->right->ecoRank)
        return leftRotate(root);

    if(balance > 1 && ecoRank > root->left->ecoRank){
        root->left = leftRotate(root->left);
        return rightRotate(root);
    }

    if(balance < -1 && ecoRank < root->right->ecoRank){
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }

    return root;
}

void inorder(Node* root){
    if(root){
        inorder(root->left);
        cout << root->locationName << " (Rank " << root->ecoRank << ")\n";
        inorder(root->right);
    }
}

int main(){
    ifstream file("eco_locations.json");
    json j;
    file >> j;

    Node* root = nullptr;

    for(auto &loc : j["eco_locations"]){
        root = insertNode(root, loc["name"], loc["rank"]);
    }

    cout << "\nAVL Tree (Sorted by Eco Rank):\n";
    inorder(root);
}

</code></pre>
        </div>
    </div>

    <!-- ---------------- ALGORITHM 2 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 2: Dijkstraâ€™s Algorithm for Eco-Friendly Route Planning</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Finds least-fuel route, not just shortest path.</li>
            <li>Uses eco-weighted edges (Green Score, emission cost).</li>
            <li>Ideal for multi-stop eco-trails.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O((V + E) log V)</b></li>
            <li>Space Complexity: <b>O(V)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('code5')">Show Algorithm Code</button> &nbsp &nbsp
  <button class="btn" onclick="runDijkstra()">Run Algorithm</button>
<div id="output-dijkstra" class="output-card"></div>
        <div id="code5" class="code-box">
<pre><code>
#include <emscripten.h>
#include <vector>
#include <queue>
#include <string>
#include <sstream>
#include "json.hpp"

using json = nlohmann::json;
using namespace std;

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_dijkstra(const char* jsonStr) {
    static string result;
    stringstream ss;

    json j = json::parse(jsonStr);
    int n = j["nodes"];
    auto edges = j["edges"];

    vector<vector<pair<int,int>>> graph(n);

    for (auto& e : edges) {
        graph[e["u"]].push_back({e["v"], e["w"]});
        graph[e["v"]].push_back({e["u"], e["w"]});
    }

    vector<int> dist(n, 1e9);
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;

    dist[0] = 0;
    pq.push({0, 0});

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();

        for (auto& edge : graph[u]) {
            int v = edge.first;
            int w = edge.second;

            if (d + w < dist[v]) {
                dist[v] = d + w;
                pq.push({dist[v], v});
            }
        }
    }

    ss << "Eco-Friendly Shortest Paths from Source:\n";
    for (int i = 0; i < n; i++) {
        ss << "Node " << i << " â†’ Cost " << dist[i] << "\n";
    }

    result = ss.str();
    return result.c_str();
}

}

</code></pre>
        </div>
    </div>

    <!-- ---------------- ALGORITHM 3 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 3: Kruskalâ€™s Minimum Spanning Tree for Eco-Zone Connectivity</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Builds a low-environmental-impact travel network.</li>
            <li>Reduces travel distance between eco-sites.</li>
            <li>Helps authorities plan walking paths, safari routes, cycling tracks with minimal disturbance.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(E log E)</b></li>
            <li>Space Complexity: <b>O(E)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('code6')">Show Algorithm Code</button>&nbsp &nbsp 
  <button class="btn" onclick="runKruskal()">Run Algorithm</button>
<div id="output-kruskal" class="output-card"></div>
        <div id="code6" class="code-box">
<pre><code>
#include <emscripten.h>
#include <vector>
#include <algorithm>
#include <string>
#include <sstream>
#include "json.hpp"

using json = nlohmann::json;
using namespace std;

struct Edge {
    int u, v, w;
};

vector<int> parent;

int findSet(int v) {
    if (v == parent[v]) return v;
    return parent[v] = findSet(parent[v]);
}

void unionSet(int a, int b) {
    a = findSet(a);
    b = findSet(b);
    if (a != b) parent[b] = a;
}

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_kruskal(const char* jsonStr) {
    static string result;
    stringstream ss;

    json j = json::parse(jsonStr);
    int n = j["nodes"];
    vector<Edge> edges;

    for (auto& e : j["edges"]) {
        edges.push_back({e["u"], e["v"], e["w"]});
    }

    parent.resize(n);
    for (int i = 0; i < n; i++)
        parent[i] = i;

    sort(edges.begin(), edges.end(),
         [](Edge a, Edge b) { return a.w < b.w; });

    ss << "Eco-Friendly Minimum Spanning Tree:\n";

    for (auto& e : edges) {
        if (findSet(e.u) != findSet(e.v)) {
            ss << e.u << " -- " << e.v
               << " (cost " << e.w << ")\n";
            unionSet(e.u, e.v);
        }
    }

    result = ss.str();
    return result.c_str();
}

}

</code></pre>
        </div>
    </div>

</div>
<!--------------idea3--------->
<div class="container">

    

    <img class="main-img" src="img3.png" alt="Delivery Routing Image">

    <h2>Description</h2>
    <p style="text-align: justify;">
        The Smart Irrigation & Paddy Water Distribution system helps farmers manage water efficiently using sensor data and intelligent allocation algorithms. It monitors soil moisture, weather, and crop stages, then adjusts irrigation schedules automatically to save water and improve crop growth.
    </p>

    <!-- ---------------- ALGORITHM 1 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 1: Segment Tree for Moisture Range Query System</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Stores moisture data for large paddy fields in segments.</li>
            <li>Supports real-time updates (new sensor data) & minimum queries.</li>
            <li>Much faster than linear search.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(log n)</b></li>
            <li>Space Complexity: <b>O(4n)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('code7')">Show Algorithm Code</button> &nbsp &nbsp
 <button class="btn" onclick="runSegment()">Run Algorithm</button>
<div id="output-segment" class="output-card"></div>
        <div id="code7" class="code-box">
<pre><code>
#include <emscripten/emscripten.h>
#include <string>
#include <vector>
#include <sstream>
#include <algorithm>

using namespace std;

vector<int> segTree;
vector<int> arr;

void build(int idx, int l, int r) {
    if (l == r) {
        segTree[idx] = arr[l];
        return;
    }
    int mid = (l + r) / 2;
    build(idx*2, l, mid);
    build(idx*2+1, mid+1, r);
    segTree[idx] = min(segTree[idx*2], segTree[idx*2+1]);
}

int query(int idx, int l, int r, int ql, int qr) {
    if (qr < l || ql > r) return 1e9;
    if (ql <= l && r <= qr) return segTree[idx];
    int mid = (l + r) / 2;
    return min(
        query(idx*2, l, mid, ql, qr),
        query(idx*2+1, mid+1, r, ql, qr)
    );
}

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_segment_tree(const char* jsonInput) {
    arr.clear();

    string s(jsonInput);
    int num = 0;
    bool reading = false;

    for (char c : s) {
        if (isdigit(c)) {
            num = num * 10 + (c - '0');
            reading = true;
        } else if (reading) {
            arr.push_back(num);
            num = 0;
            reading = false;
        }
    }
    if (reading) arr.push_back(num);

    int n = arr.size();
    segTree.assign(4*n, 0);
    build(1, 0, n-1);

    int result = query(1, 0, n-1, 1, 4);

    static string output;
    output = "Minimum moisture between index 1 and 4 = " + to_string(result);
    return output.c_str();
}
}


</code></pre>
        </div>
    </div>

    <!-- ---------------- ALGORITHM 2 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 2: Min-Heap for Water Demand Priority</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Uses min-heap to always select the lowest moisture region first.</li>
            <li>Dynamic update of moisture levels triggers re-prioritization.</li>
            <li>Efficient for hundreds of sensors and field partitions.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: Insert: <b>O(log n)</b></li>
            <li>Space Complexity: <b>O(n)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('code8')">Show Algorithm Code</button>&nbsp &nbsp
 <button class="btn" onclick="runMinHeap()">Run Algorithm</button>
<div id="output-minheap" class="output-card"></div>
        <div id="code8" class="code-box">
<pre><code>
#include <emscripten/emscripten.h>
#include <queue>
#include <string>
#include <vector>

using namespace std;

struct Field {
    int moisture;
    string name;
};

struct Compare {
    bool operator()(Field a, Field b) {
        return a.moisture > b.moisture;
    }
};

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_min_heap(const char* jsonInput) {
    priority_queue<Field, vector<Field>, Compare> pq;

    string s(jsonInput);
    string name = "";
    int moisture = 0;
    bool readingName = false;

    for (char c : s) {
        if (c == '"') {
            readingName = !readingName;
            if (!readingName && !name.empty() && moisture > 0) {
                pq.push({moisture, name});
                name = "";
                moisture = 0;
            }
        } else if (readingName && isalpha(c)) {
            name += c;
        } else if (isdigit(c)) {
            moisture = moisture * 10 + (c - '0');
        }
    }

    Field driest = pq.top();

    static string output;
    output = "Highest priority field: " + driest.name +
             " (Moisture = " + to_string(driest.moisture) + ")";
    return output.c_str();
}
}


</code></pre>
        </div>
    </div>

    <!-- ---------------- ALGORITHM 3 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 3: Dijkstra-Based Water Routing Optimization</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Finds the minimum-cost water path from source (reservoir/main canal) to driest field.</li>
            <li>Ensures water reaches field efficiently with minimal loss.</li>
            <li>Ideal for large-scale paddy field networks with branching channels.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O((V + E) log V)</b></li>
            <li>Space Complexity: <b>O(V + E)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('code9')">Show Algorithm Code</button>&nbsp &nbsp
<button class="btn" onclick="runIrrigationDijkstra()">Run Algorithm</button>
<div id="output-irrigation-dijkstra" class="output-card"></div>
        <div id="code9" class="code-box">
<pre><code>
#include <emscripten/emscripten.h>
#include <vector>
#include <queue>
#include <string>

using namespace std;

struct Edge {
    int to, cost;
};

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_dijkstra(const char* jsonInput) {
    vector<vector<Edge>> graph(5);

    // Hardcoded graph for demo (matches JSON)
    graph[0].push_back({1,10});
    graph[0].push_back({2,5});
    graph[2].push_back({4,2});
    graph[1].push_back({3,1});
    graph[4].push_back({3,4});

    vector<int> dist(5, 1e9);
    dist[0] = 0;

    priority_queue<pair<int,int>,
                   vector<pair<int,int>>,
                   greater<pair<int,int>>> pq;

    pq.push({0,0});

    while (!pq.empty()) {
        auto [cost, u] = pq.top();
        pq.pop();
        if (cost > dist[u]) continue;

        for (auto &e : graph[u]) {
            if (dist[u] + e.cost < dist[e.to]) {
                dist[e.to] = dist[u] + e.cost;
                pq.push({dist[e.to], e.to});
            }
        }
    }

    static string output;
    output = "Minimum water cost to Field 3 = " + to_string(dist[3]);
    return output.c_str();
}
}


</code></pre>
        </div>
    </div>

</div>
 <!--------------idea4--------->
<div class="container">

   

    <img class="main-img" src="img4.png" alt="Delivery Routing Image">

    <h2>Description</h2>
    <p style="text-align:justify;">  
        Autonomous robots patrol beaches, detect waste using sensors, and collect it efficiently with smart path-planning algorithms.
        They maintain cleaner beaches with less manual labor and support sustainable coastal management.
    </p>

    <!-- ================= ALGORITHM 1 ================= -->
    <div class="algo-section">
        <h2>Algorithm 1: BFS (Breadth-First Search) for Debris Zone Scanning</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Scans the beach level-by-level.</li>
            <li>Detects clusters of litter in all reachable directions.</li>
            <li>Ensures complete coverage without missing any zone.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(V + E)</b></li>
            <li>Space Complexity: <b>O(V)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('code10')">Show Algorithm Code</button>&nbsp &nbsp
 <button class="btn" onclick="runBeachBFS()">Run Algorithm</button>
<div id="output-bfs" class="output-card"></div>
        <div id="code10" class="code-box">
<pre>
#include <emscripten/emscripten.h>
#include <string>
#include <queue>
#include <vector>
#include <sstream>
#include "json.hpp"

using json = nlohmann::json;
using namespace std;

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_bfs(const char* input) {
    static string output;
    output.clear();

    json j = json::parse(input);
    vector<vector<int>> grid = j["grid"];

    int rows = grid.size();
    int cols = grid[0].size();

    vector<vector<bool>> visited(rows, vector<bool>(cols, false));
    int dx[4] = {1, -1, 0, 0};
    int dy[4] = {0, 0, 1, -1};

    queue<pair<int,int>> q;

    for(int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            if(grid[i][j] == 1 && !visited[i][j]){
                q.push({i,j});
                visited[i][j] = true;

                while(!q.empty()){
                    auto [x,y] = q.front(); q.pop();
                    output += "Debris at (" + to_string(x) + "," + to_string(y) + ")\n";

                    for(int k=0;k<4;k++){
                        int nx = x + dx[k];
                        int ny = y + dy[k];
                        if(nx>=0 && ny>=0 && nx<rows && ny<cols &&
                           grid[nx][ny]==1 && !visited[nx][ny]){
                            visited[nx][ny] = true;
                            q.push({nx,ny});
                        }
                    }
                }
            }
        }
    }
    return output.c_str();
}
}

</pre>
        </div>
    </div>

    <!-- ================= ALGORITHM 2 ================= -->
    <div class="algo-section">
        <h2>Algorithm 2: Dijkstra for Energy-Efficient Routes</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Finds cheapest path based on energy usage.</li>
            <li>Minimizes friction losses on loose sand.</li>
            <li>Ignores heuristics, purely cost-based.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(E log V)</b></li>
            <li>Space Complexity: <b>O(V)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('code11')">Show Algorithm Code</button>&nbsp &nbsp
 <button class="btn" onclick="runBeachDijkstra()">Run Algorithm</button>
<div id="output-energy-dijkstra" class="output-card"></div>
        <div id="code11" class="code-box">
<pre>
#include <emscripten/emscripten.h>
#include <string>
#include <vector>
#include <queue>
#include <limits>
#include "json.hpp"

using json = nlohmann::json;
using namespace std;

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_dijkstra(const char* input) {
    static string output;
    output.clear();

    json j = json::parse(input);
    vector<vector<int>> graph = j["graph"];
    int src = j["source"];

    int n = graph.size();
    vector<int> dist(n, numeric_limits<int>::max());
    dist[src] = 0;

    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
    pq.push({0, src});

    while(!pq.empty()){
        auto [d,u] = pq.top(); pq.pop();
        for(int v=0; v<n; v++){
            if(graph[u][v] > 0 && dist[v] > dist[u] + graph[u][v]){
                dist[v] = dist[u] + graph[u][v];
                pq.push({dist[v], v});
            }
        }
    }

    for(int i=0;i<n;i++)
        output += "Energy cost to node " + to_string(i) + " = " + to_string(dist[i]) + "\n";

    return output.c_str();
}
}

</pre>
        </div>
    </div>

    <!-- ================= ALGORITHM 3 ================= -->
    <div class="algo-section">
        <h2>Algorithm 3: Heapification for Optimized Garbage Collection</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Prioritizes largest waste clusters first.</li>
            <li>Robot maximizes efficiency per trip.</li>
            <li>Reduces battery usage and travel time.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(log n)</b></li>
            <li>Space Complexity: <b>O(n)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('code12')">Show Algorithm Code</button>&nbsp &nbsp
 <button class="btn" onclick="runGarbageHeap()">Run Algorithm</button>
<div id="output-garbage-heap" class="output-card"></div>
        <div id="code12" class="code-box">
<pre>
#include <emscripten/emscripten.h>
#include <string>
#include <queue>
#include "json.hpp"

using json = nlohmann::json;
using namespace std;

struct Waste {
    int amount;
    string zone;
};

struct Compare {
    bool operator()(Waste a, Waste b){
        return a.amount < b.amount;
    }
};

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_heap(const char* input) {
    static string output;
    output.clear();

    json j = json::parse(input);
    priority_queue<Waste, vector<Waste>, Compare> pq;

    for(auto &w : j["waste"]){
        pq.push({ w["amount"], w["zone"] });
    }

    while(!pq.empty()){
        Waste w = pq.top(); pq.pop();
        output += "Collecting " + w.zone +
                  " (Waste=" + to_string(w.amount) + ")\n";
    }

    return output.c_str();
}
}

</pre>
        </div>
    </div>

</div>
<!--------------idea5--------->
<div class="container">

  

    <img class="main-img" src="img6.png" alt="Solar Trading Image">

    <h2>Description</h2>
    <p style="text-align: justify;">
        A decentralized solar platform where households generate, trade, and distribute micro-solar energy effectively using graph algorithms.
    </p>

    <!-- ---------------- ALGORITHM 1 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 1: DFS (Depth-First Search) for Deep Energy Flow Mapping</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Traverses solar nodes deeply and recursively.</li>
            <li>Finds long chains of connected producers.</li>
            <li>Helps in analyzing micro-grid stability.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(V + E)</b></li>
            <li>Space Complexity: <b>O(V)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('algoDFS')">Show Algorithm Code</button>&nbsp &nbsp
  <button class="btn" onclick="runSolarDFS()">Run Algorithm</button>
<div id="output-solar-dfs" class="output-card"></div>
        <div id="algoDFS" class="code-box">
<pre><code>
#include <emscripten.h>
#include <iostream>
#include <vector>
#include <string>
#include <sstream>

using namespace std;

/*
JSON FORMAT:
{
  "nodes": 6,
  "adj": [
    [1,2],
    [0,3],
    [0,4],
    [1,5],
    [2],
    [3]
  ]
}
*/

void dfsUtil(int u, vector<vector<int>>& adj, vector<bool>& vis, stringstream& out) {
    vis[u] = true;
    out << "Energy Node: " << u << "\n";
    for (int v : adj[u]) {
        if (!vis[v]) dfsUtil(v, adj, vis, out);
    }
}

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_dfs(const char* jsonStr) {
    static string result;
    string s(jsonStr);

    int n = stoi(s.substr(s.find("nodes") + 7));
    vector<vector<int>> adj(n);

    int pos = s.find("adj");
    pos = s.find("[", pos);

    for (int i = 0; i < n; i++) {
        pos = s.find("[", pos + 1);
        int end = s.find("]", pos);
        string row = s.substr(pos + 1, end - pos - 1);

        stringstream ss(row);
        int x;
        while (ss >> x) {
            adj[i].push_back(x);
            ss.ignore();
        }
        pos = end;
    }

    vector<bool> vis(n, false);
    stringstream out;
    out << "DFS Energy Flow:\n";

    for (int i = 0; i < n; i++)
        if (!vis[i]) dfsUtil(i, adj, vis, out);

    result = out.str();
    return result.c_str();
}

}

</code></pre>
        </div>
    </div>


    <!-- ---------------- ALGORITHM 2 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 2: Dijkstra for Efficient Energy Routing (Low-Loss Transfer)</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Finds the lowest-loss path between solar nodes.</li>
            <li>Routes surplus energy to homes demanding power.</li>
            <li>Ensures optimal energy transfers.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(E log V)</b></li>
            <li>Space Complexity: <b>O(V)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('algoDijkstra')">Show Algorithm Code</button>&nbsp &nbsp
  <button class="btn" onclick="runSolarDijkstra()">Run Algorithm</button>
<div id="output-solar-dijkstra" class="output-card"></div>
      <div id="algoDijkstra" class="code-box">
<pre><code>
#include <emscripten.h>
#include <iostream>
#include <vector>
#include <queue>
#include <sstream>
#include <limits>

using namespace std;

/*
JSON FORMAT:
{
  "cost": [
    [0,4,0,0],
    [4,0,8,0],
    [0,8,0,2],
    [0,0,2,0]
  ],
  "source": 0
}
*/

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_dijkstra(const char* jsonStr) {
    static string result;
    string s(jsonStr);

    int src = stoi(s.substr(s.find("source") + 9));
    vector<vector<int>> cost;

    int pos = s.find("[");
    while (true) {
        int start = s.find("[", pos + 1);
        if (start == string::npos) break;
        int end = s.find("]", start);
        string row = s.substr(start + 1, end - start - 1);

        vector<int> r;
        stringstream ss(row);
        int x;
        while (ss >> x) {
            r.push_back(x);
            ss.ignore();
        }
        cost.push_back(r);
        pos = end;
    }

    int n = cost.size();
    vector<int> dist(n, INT_MAX);
    dist[src] = 0;

    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
    pq.push({0, src});

    while (!pq.empty()) {
        auto [d,u] = pq.top(); pq.pop();
        for (int v = 0; v < n; v++) {
            if (cost[u][v] && dist[v] > d + cost[u][v]) {
                dist[v] = d + cost[u][v];
                pq.push({dist[v], v});
            }
        }
    }

    stringstream out;
    out << "Minimum Energy Loss Paths:\n";
    for (int i = 0; i < n; i++)
        out << "Node " << i << " -> " << dist[i] << "\n";

    result = out.str();
    return result.c_str();
}

}

</code></pre>
        </div>
    </div>


    <!-- ---------------- ALGORITHM 3 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 3: Bellman-Ford for Dynamic Energy Pricing & Flexible Trading</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Handles negative weights such as night-time discounts, demand drops, surge rates.</li>
            <li>Finds cheapest trading paths when grid conditions change.</li>
            <li>Detects negative cycles (energy loss loops).</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(V * E)</b></li>
            <li>Space Complexity: <b>O(V)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('algoBellman')">Show Algorithm Code</button>&nbsp &nbsp
  <button class="btn" onclick="runBellmanFord()">Run Algorithm</button>
<div id="output-bellman" class="output-card"></div>
      <div id="algoBellman" class="code-box">
<pre><code>
#include <emscripten.h>
#include <iostream>
#include <vector>
#include <sstream>

using namespace std;

/*
JSON FORMAT:
{
  "V": 5,
  "edges": [
    [0,1,6],
    [0,2,7],
    [1,3,5],
    [1,4,-4],
    [2,3,-3]
  ],
  "source": 0
}
*/

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_bellman(const char* jsonStr) {
    static string result;
    string s(jsonStr);

    int V = stoi(s.substr(s.find("V") + 3));
    int src = stoi(s.substr(s.find("source") + 9));

    vector<vector<int>> edges;
    int pos = s.find("edges");

    while (true) {
        int start = s.find("[", pos + 1);
        if (start == string::npos) break;
        int end = s.find("]", start);
        string row = s.substr(start + 1, end - start - 1);

        vector<int> e;
        stringstream ss(row);
        int x;
        while (ss >> x) {
            e.push_back(x);
            ss.ignore();
        }
        if (e.size() == 3) edges.push_back(e);
        pos = end;
    }

    vector<int> dist(V, 1e9);
    dist[src] = 0;

    for (int i = 1; i < V; i++)
        for (auto &e : edges)
            if (dist[e[0]] + e[2] < dist[e[1]])
                dist[e[1]] = dist[e[0]] + e[2];

    stringstream out;
    out << "Best Trading Prices:\n";
    for (int i = 0; i < V; i++)
        out << "Node " << i << " -> " << dist[i] << "\n";

    result = out.str();
    return result.c_str();
}

}

</code></pre>
        </div>
    </div>

</div>
<!-------------idea6----->
<div class="container">

   

    <img class="main-img" 
        src="img8.png"
        alt="Fishery Optimization Image">

    <h2>Description</h2>
    <p style="text-align: justify;">
        The Fishery Fuel Optimization System helps fishing boats reduce fuel consumption 
        by analyzing marine currents, identifying fuel-heavy zones, and generating the most 
        efficient navigation routes. Using advanced algorithms like BFS, DFS, and Dijkstra, 
        the system ensures optimal fuel-saving travel, safer navigation, and smarter fleet 
        decision-making for sustainable fishing operations.
    </p>

    <!-- ---------------- ALGORITHM 1 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 1: BFS for Fuel Zone Monitoring</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Scans marine zones level-by-level to detect high fuel consumption areas.</li>
            <li>Identifies strong currents or resistance patterns affecting fuel usage.</li>
            <li>Builds a fuel heatmap of connected sea regions.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(V + E)</b></li>
            <li>Space Complexity: <b>O(V)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('algo3')">Show Algorithm Code</button>&nbsp &nbsp 
 <button class="btn" onclick="runFuelBFS()">Run Algorithm</button>
<div id="output-fuel-bfs" class="output-card"></div>
      <div id="algo3" class="code-box">
<pre><code>
#include <emscripten.h>
#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <queue>

using namespace std;

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_bfs(const char* jsonStr) {
    static string result;
    string s(jsonStr);

    // Parse number of nodes
    int n = 0;
    int pos_nodes = s.find("nodes");
    if (pos_nodes != string::npos) {
        string number;
        for (size_t i = pos_nodes; i < s.size(); i++) {
            if (isdigit(s[i])) number += s[i];
            else if (!number.empty()) break;
        }
        n = stoi(number);
    }

    vector<vector<int>> adj(n);

    // Parse adjacency list safely
    int pos = s.find("adj");
    pos = s.find("[", pos);
    for (int i = 0; i < n; i++) {
        pos = s.find("[", pos + 1);
        int end_row = s.find("]", pos);
        string row = s.substr(pos + 1, end_row - pos - 1);

        stringstream ss(row);
        string token;
        while (getline(ss, token, ',')) {
            stringstream ts(token);
            int num;
            if (ts >> num) adj[i].push_back(num);
        }

        pos = end_row;
    }

    vector<bool> vis(n, false);
    stringstream out;
    out << "BFS Fuel Zones:\n";

    for (int i = 0; i < n; i++) {
        if (!vis[i]) {
            queue<int> q;
            q.push(i);
            vis[i] = true;

            while (!q.empty()) {
                int u = q.front(); q.pop();
                out << "Monitoring Fuel Zone: " << u << "\n";
                for (int v : adj[u]) {
                    if (!vis[v]) {
                        vis[v] = true;
                        q.push(v);
                    }
                }
            }
        }
    }

    result = out.str();
    return result.c_str();
}

}

</code></pre>
        </div>
    </div>

    <!-- ---------------- ALGORITHM 2 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 2: DFS for Deep Fuel Pattern Analysis</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Explores marine regions deeply to identify long fuel-intensive routes.</li>
            <li>Detects hidden water paths with high resistance.</li>
            <li>Helps analyze long-term fuel behavior across connected routes.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(V + E)</b></li>
            <li>Space Complexity: <b>O(V)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('algo4')">Show Algorithm Code</button>&nbsp &nbsp
 <button class="btn" onclick="runFuelDFS()">Run Algorithm</button>
<div id="output-fuel-dfs" class="output-card"></div>       <div id="algo4" class="code-box">
<pre><code>
#include <emscripten.h>
#include <iostream>
#include <vector>
#include <string>
#include <sstream>

using namespace std;

void dfsUtil(int u, vector<vector<int>>& adj, vector<bool>& vis, stringstream& out) {
    vis[u] = true;
    out << "Analyzing Fuel Pattern (DFS Zone): " << u << "\n";
    for (int v : adj[u]) {
        if (!vis[v]) dfsUtil(v, adj, vis, out);
    }
}

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_dfs(const char* jsonStr) {
    static string result;
    string s(jsonStr);

    // Parse number of nodes
    int n = 0;
    int pos_nodes = s.find("nodes");
    if (pos_nodes != string::npos) {
        string number;
        for (size_t i = pos_nodes; i < s.size(); i++) {
            if (isdigit(s[i])) number += s[i];
            else if (!number.empty()) break;
        }
        n = stoi(number);
    }

    vector<vector<int>> adj(n);

    // Parse adjacency list safely
    int pos = s.find("adj");
    pos = s.find("[", pos);
    for (int i = 0; i < n; i++) {
        pos = s.find("[", pos + 1);
        int end_row = s.find("]", pos);
        string row = s.substr(pos + 1, end_row - pos - 1);

        stringstream ss(row);
        string token;
        while (getline(ss, token, ',')) {
            stringstream ts(token);
            int num;
            if (ts >> num) adj[i].push_back(num);
        }

        pos = end_row;
    }

    vector<bool> vis(n, false);
    stringstream out;
    out << "DFS Fuel Pattern Analysis:\n";

    for (int i = 0; i < n; i++)
        if (!vis[i]) dfsUtil(i, adj, vis, out);

    result = out.str();
    return result.c_str();
}

}

</code></pre>
        </div>
    </div>

    <!-- ---------------- ALGORITHM 3 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 3: Dijkstra for Fuel-Efficient Marine Navigation</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Calculates the most fuel-efficient routes between sea zones.</li>
            <li>Avoids high-drag water regions and unfavorable current areas.</li>
            <li>Helps boats reach fishing locations with minimal fuel waste.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(E log V)</b></li>
            <li>Space Complexity: <b>O(V)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('algo5')">Show Algorithm Code</button>&nbsp &nbsp
 <button class="btn" onclick="runFuelDijkstra()">Run Algorithm</button>
<div id="output-fuel-dijkstra" class="output-card"></div>      <div id="algo5" class="code-box">
<pre><code>
#include <emscripten.h>
#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <limits>
#include <queue>

using namespace std;

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_dijkstra(const char* jsonStr) {
    static string result;
    string s(jsonStr);

    // Parse number of nodes
    int n = 0;
    int pos_nodes = s.find("nodes");
    if (pos_nodes != string::npos) {
        string number;
        for (size_t i = pos_nodes; i < s.size(); i++) {
            if (isdigit(s[i])) number += s[i];
            else if (!number.empty()) break;
        }
        n = stoi(number);
    }

    vector<vector<int>> graph(n, vector<int>(n, 0));

    // Parse adjacency matrix safely
    int pos = s.find("graph");
    pos = s.find("[", pos);
    for (int i = 0; i < n; i++) {
        pos = s.find("[", pos + 1);
        int end_row = s.find("]", pos);
        string row = s.substr(pos + 1, end_row - pos - 1);

        stringstream ss(row);
        string token;
        int j = 0;
        while (getline(ss, token, ',')) {
            stringstream ts(token);
            int val;
            if (ts >> val) graph[i][j++] = val;
        }

        pos = end_row;
    }

    // Dijkstra
    vector<int> dist(n, numeric_limits<int>::max());
    dist[0] = 0;
    using pii = pair<int,int>;
    priority_queue<pii, vector<pii>, greater<pii>> pq;
    pq.push({0,0});

    stringstream out;
    out << "Dijkstra Fuel-Efficient Routes:\n";

    while (!pq.empty()) {
        auto [d,u] = pq.top(); pq.pop();
        for (int v = 0; v < n; v++) {
            if (graph[u][v] != 0 && dist[v] > dist[u] + graph[u][v]) {
                dist[v] = dist[u] + graph[u][v];
                pq.push({dist[v], v});
            }
        }
    }

    for (int i = 0; i < n; i++)
        out << "Fuel to reach zone " << i << ": " << dist[i] << "\n";

    result = out.str();
    return result.c_str();
}

}

</code></pre>
        </div>
    </div>

</div>
<!----------idea7----->
<div class="container">

   

    <img class="main-img" 
        src="img9.png"
        alt="Smart Farming Image">

    <h2>Description</h2>
    <p style="text-align: justify;">
        The Smart Farmers Price Formatting Platform helps farmers analyze market 
        prices, understand supply-demand fluctuations, and choose the most profitable 
        market for selling their crops. Using intelligent algorithms, the system evaluates 
        market behavior, predicts future pricing trends, and provides automated guidance 
        for farmers to maximize income and reduce losses.
    </p>

    <!-- ---------------- ALGORITHM 1 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 1: BFS for Supplyâ€“Demand Zone Tracking</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Scans market regions level-by-level to detect surplus and shortage zones.</li>
            <li>Helps build a localized crop-demand heatmap.</li>
            <li>Identifies connected market clusters that influence pricing.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(V + E)</b></li>
            <li>Space Complexity: <b>O(V)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('algo6')">Show Algorithm Code</button>
<button class="btn" onclick="runMarketBFS()">Run Algorithm</button>
<div id="output-market-bfs" class="output-card"></div>
        <div id="algo6" class="code-box">
<pre><code>
#include <emscripten/emscripten.h>
#include <string>
#include <vector>
#include <queue>
#include "json.hpp"

using json = nlohmann::json;
using namespace std;

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_bfs(const char* input) {
    static string output;
    output.clear();

    json j = json::parse(input);
    json zones_json = j["zones"];

    int n = zones_json.size();
    vector<vector<int>> graph(n);
    for (auto& [key, val] : zones_json.items()) {
        int u = stoi(key);
        for (auto v : val) graph[u].push_back(v);
    }

    vector<bool> visited(n, false);
    queue<int> q;
    q.push(0);
    visited[0] = true;

    while(!q.empty()){
        int u = q.front(); q.pop();
        output += "Visiting Market Zone " + to_string(u) + "\n";
        for(int v : graph[u]){
            if(!visited[v]){
                visited[v] = true;
                q.push(v);
            }
        }
    }

    return output.c_str();
}
}

</code></pre>
        </div>
    </div>

    <!-- ---------------- ALGORITHM 2 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 2: Dijkstraâ€™s Algorithm for Price Optimization Routing</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Finds the most profitable market with the lowest price difference.</li>
            <li>Considers transport cost and market fluctuation weightage.</li>
            <li>Ideal for helping farmers choose the best selling point.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(E log V)</b></li>
            <li>Space Complexity: <b>O(V)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('algo7')">Show Algorithm Code</button>
<button class="btn" onclick="runMarketDijkstra()">Run Algorithm</button>
<div id="output-market-dijkstra" class="output-card"></div>
        <div id="algo7" class="code-box">
<pre><code>
#include <emscripten/emscripten.h>
#include <string>
#include <vector>
#include <queue>
#include <limits>
#include "json.hpp"

using json = nlohmann::json;
using namespace std;

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_dijkstra(const char* input){
    static string output;
    output.clear();

    json j = json::parse(input);
    vector<vector<int>> graph = j["graph"];
    int src = j.value("source", 0);

    int n = graph.size();
    vector<int> dist(n, numeric_limits<int>::max());
    dist[src] = 0;

    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
    pq.push({0, src});

    while(!pq.empty()){
        auto [d, u] = pq.top(); pq.pop();
        for(int v = 0; v < n; v++){
            if(graph[u][v] > 0 && dist[v] > dist[u] + graph[u][v]){
                dist[v] = dist[u] + graph[u][v];
                pq.push({dist[v], v});
            }
        }
    }

    for(int i = 0; i < n; i++)
        output += "Optimal price path to market " + to_string(i) + " = " + to_string(dist[i]) + "\n";

    return output.c_str();
}
}

</code></pre>
        </div>
    </div>

    <!-- ---------------- ALGORITHM 3 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 3: Max-Heap for Ranking High-Demand Crops</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Keeps track of crops with highest demand first.</li>
            <li>Helps the platform decide priority pricing for farmers.</li>
            <li>Aids in scheduling crop sales during peak demand seasons.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Build Heap: <b>O(n)</b></li>
            <li>Insert/Delete: <b>O(log n)</b></li>
            <li>Space Complexity: <b>O(n)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('algo8')">Show Algorithm Code</button>
<button class="btn" onclick="runCropHeap()">Run Algorithm</button>
<div id="output-crop-heap" class="output-card"></div>
 
        <div id="algo8" class="code-box">
<pre><code>
#include <emscripten/emscripten.h>
#include <queue>
#include <string>
#include <vector>
#include "json.hpp"

using json = nlohmann::json;
using namespace std;

struct Crop {
    int demand;
    string name;
};

struct Compare {
    bool operator()(Crop a, Crop b) {
        return a.demand < b.demand; // max-heap
    }
};

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_heap(const char* input){
    static string output;
    output.clear();

    json j = json::parse(input);
    auto crops_json = j["crops"];

    priority_queue<Crop, vector<Crop>, Compare> pq;
    for(auto& c : crops_json){
        pq.push({c["demand"], c["name"]});
    }

    while(!pq.empty()){
        Crop c = pq.top(); pq.pop();
        output += "High-Demand Crop: " + c.name + " | Demand Score: " + to_string(c.demand) + "\n";
    }

    return output.c_str();
}
}

</code></pre>
        </div>
    </div>

</div>
<!----idea8------->
<div class="container">

   

    <img class="main-img" 
        src="img10.png"
        alt="Water Taxi Routing Image">

    <h2>Description</h2>
    <p style="text-align: justify;">
        The Water Taxi & Coastal Routing Platform provides fast and optimized 
        water-based transportation across rivers, lakes, and coastal regions. 
        Using advanced routing, scheduling, and navigation algorithms, the system 
        reduces travel time, improves fuel efficiency, enhances passenger safety, 
        and helps operators choose the best possible marine routes under dynamic 
        water and weather conditions.
    </p>

    <!-- ---------------- ALGORITHM 1 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 1: BFS for Reachability Across Water Routes</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Determines all reachable water points from a starting dock.</li>
            <li>Maps safe water corridors for navigation.</li>
            <li>Useful for emergency path discovery and blocked-route detection.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(V + E)</b></li>
            <li>Space Complexity: <b>O(V)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('algorithm')">Show Algorithm Code</button>
<button class="btn" onclick="runWaterBFS()">Run Algorithm</button>
<div id="output-water-bfs" class="output-card"></div>
        <div id="algorithm" class="code-box">
<pre><code>
#include <emscripten/emscripten.h>
#include <string>
#include <vector>
#include <queue>
#include "json.hpp"

using json = nlohmann::json;
using namespace std;

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_bfs(const char* input) {
    static string output;
    output.clear();

    json j = json::parse(input);
    auto waterPoints = j["waterPoints"];
    auto edges = j["edges"];

    int n = waterPoints.size();
    vector<vector<int>> graph(n);
    for (auto &e : edges) {
        int u = e["from"];
        int v = e["to"];
        graph[u].push_back(v);
        graph[v].push_back(u); // assuming undirected
    }

    vector<bool> visited(n, false);
    queue<int> q;
    q.push(0);
    visited[0] = true;

    output += "BFS Reachability from Dock 0:\n";
    while(!q.empty()){
        int u = q.front(); q.pop();
        output += waterPoints[u].get<string>() + "\n";
        for(int v : graph[u]){
            if(!visited[v]){
                visited[v] = true;
                q.push(v);
            }
        }
    }

    return output.c_str();
}
}

</code></pre>
        </div>
    </div>

    <!-- ---------------- ALGORITHM 2 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 2: Dijkstraâ€™s Algorithm for Fastest Coastal Route</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Finds the fastest route between docks considering travel time.</li>
            <li>Considers wave resistance and marine traffic delays.</li>
            <li>Ideal for optimizing passenger transport schedules.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Time Complexity: <b>O(E log V)</b></li>
            <li>Space Complexity: <b>O(V)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('algorithm1')">Show Algorithm Code</button>
<button class="btn" onclick="runWaterDijkstra()">Run Algorithm</button>
<div id="output-water-dijkstra" class="output-card"></div>
        <div id="algorithm1" class="code-box">
<pre><code>
#include <emscripten/emscripten.h>
#include <string>
#include <vector>
#include <queue>
#include <limits>
#include "json.hpp"

using json = nlohmann::json;
using namespace std;

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_dijkstra(const char* input) {
    static string output;
    output.clear();

    json j = json::parse(input);
    auto waterPoints = j["waterPoints"];
    auto edges = j["edges"];

    int n = waterPoints.size();
    vector<vector<int>> graph(n, vector<int>(n, 0));

    for (auto &e : edges) {
        int u = e["from"];
        int v = e["to"];
        int t = e["time"];
        graph[u][v] = t;
        graph[v][u] = t; // assuming undirected
    }

    vector<int> dist(n, numeric_limits<int>::max());
    dist[0] = 0;

    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
    pq.push({0,0});

    while(!pq.empty()){
        auto [d,u] = pq.top(); pq.pop();
        if(d > dist[u]) continue;

        for(int v=0; v<n; ++v){
            if(graph[u][v] && dist[v] > dist[u] + graph[u][v]){
                dist[v] = dist[u] + graph[u][v];
                pq.push({dist[v], v});
            }
        }
    }

    output += "Fastest time from Dock 0:\n";
    for(int i=0; i<n; ++i){
        output += waterPoints[i].get<string>() + ": " + to_string(dist[i]) + " minutes\n";
    }

    return output.c_str();
}
}

</code></pre>
        </div>
    </div>

    <!-- ---------------- ALGORITHM 3 ---------------- -->
    <div class="algo-section">
        <h2>Algorithm 3: Priority Queue (Min-Heap) for Marine Trip Scheduling</h2>

        <p><b>How this algorithm is helpful?</b></p>
        <ul>
            <li>Schedules boat trips based on shortest waiting time.</li>
            <li>Ensures evenly distributed passenger loads.</li>
            <li>Improves overall coastal transport efficiency.</li>
        </ul>

        <p><b>Efficiency:</b></p>
        <ul>
            <li>Insert/Delete: <b>O(log n)</b></li>
            <li>Space Complexity: <b>O(n)</b></li>
        </ul>

        <button class="btn" onclick="toggleCode('algorithm2')">Show Algorithm Code</button>
<button class="btn" onclick="runTripScheduler()">Run Algorithm</button>
<div id="output-trip-heap" class="output-card"></div>
        <div id="algorithm2" class="code-box">
<pre><code>
#include <emscripten/emscripten.h>
#include <string>
#include <queue>
#include "json.hpp"

using json = nlohmann::json;
using namespace std;

struct Trip {
    int waitTime;
    string routeName;
};

struct CompareTrips {
    bool operator()(Trip a, Trip b) {
        return a.waitTime > b.waitTime; // min-heap
    }
};

priority_queue<Trip, vector<Trip>, CompareTrips> tripSchedule;

extern "C" {

EMSCRIPTEN_KEEPALIVE
const char* run_heap(const char* input) {
    static string output;
    output.clear();

    json j = json::parse(input);
    auto trips = j["trips"];

    while(!tripSchedule.empty()) tripSchedule.pop();

    for(auto &t : trips){
        tripSchedule.push({t["waitTime"], t["routeName"]});
    }

    output += "Scheduled Trips by Wait Time:\n";
    while(!tripSchedule.empty()){
        Trip t = tripSchedule.top(); tripSchedule.pop();
        output += t.routeName + " | Wait Time: " + to_string(t.waitTime) + " minutes\n";
    }

    return output.c_str();
}
}

</code></pre>
        </div>
    </div>

</div>
<!----------Reflections -->
<div class="container">

    <h1 class="fancy-title">Course Reflections </h1>

 

    <p>
        The Design and Analysis of Algorithms course has profoundly enhanced my comprehension 
        of core data structures and algorithms and their practical applications in solving 
        computational problems. Understanding tree-based structures such as Binary Search 
        Trees (BSTs), AVL trees, and Red-Black trees provided clarity on self-balancing 
        mechanisms that ensure logarithmic insertion, deletion, and search operations.
    </p>

    <p>
        Deep exploration of heaps and the process of heapification strengthened my knowledge 
        of priority queues and their role in efficient scheduling and sorting. Advanced data 
        structures such as segment trees, lookup tables, and skip lists introduced robust 
        strategies for optimizing range queries, supporting dynamic updates, and enabling 
        probabilistic search operations.
    </p>

    <p>
        Traversal techniques such as DFS and BFS highlighted systematic approaches to graph 
        exploration, while studying shortest path algorithmsâ€”including Dijkstra, Bellmanâ€“Ford, 
        and Floydâ€“Warshallâ€”refined my ability to solve complex weighted graph problems under 
        varying constraints.
    </p>

    <p>
        The detailed study of classical sorting algorithmsâ€”bubble, selection, insertion, merge, 
        and quick sortâ€”allowed me to evaluate time-space trade-offs, stability, and performance 
        in best, average, and worst-case scenarios. Pattern matching algorithms such as KMP and 
        Rabinâ€“Karp further deepened my understanding of efficient string-processing techniques.
    </p>

    <p>
        One of the most transformative components of this course was algorithmic efficiency 
        analysis. Examining C++ implementations to derive computational complexity using 
        Big-O, Big-Theta, and Big-Omega notations helped me recognize the impact of loop 
        structures, recursion, and optimization choices. This strengthened my ability to select 
        the right data structure and design optimized solutions tailored to real-world 
        applications, from transportation networks to resource allocation and auction systems.
    </p>

</div>

<script>
function toggleCode(id) {
    let box = document.getElementById(id);
    box.style.display = (box.style.display === "none") ? "block" : "none";
}




</script>
<script type="module" src="script.js"></script>


</body>
</html>
