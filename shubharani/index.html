v<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Comprehensive Sustainable City Business Ideas: Algorithmic Suite (17 Initiatives)</title>
    <style>
        /* --- PROFESSIONAL BASE STYLES --- */
        body {
            font-family: 'Georgia', 'Times New Roman', serif; /* Formal/Professional Font */
            background-color: #f0f2f5; /* Very Light Blue-Gray Background */
            margin: 0;
            padding: 30px;
            color: #212529; /* Deep Charcoal Text */
        }
        .main-content {
            max-width: 1300px;
            margin: 0 auto;
        }

        /* --- HEADER & TITLES --- */
        .header-container {
            background-color: #001f40; /* Very Dark Navy Blue */
            color: white;
            padding: 45px 30px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 40px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        .header-container h1 { 
            font-family: 'Playfair Display', serif; /* Elegant Title Font */
            font-size: 2.8rem; 
            margin-bottom: 10px; 
            font-weight: 700;
        }
        .header-container p { 
            font-size: 1.1rem; 
            opacity: 0.85;
        }

        /* --- SECTION HEADINGS --- */
        .category-heading {
            color: #0056b3; /* Primary Blue Accent */
            border-bottom: 4px solid #0056b3;
            padding-bottom: 10px;
            margin-top: 45px;
            margin-bottom: 25px;
            font-size: 2.2rem;
            font-weight: 600;
            font-family: 'Segoe UI', sans-serif;
        }

        /* --- INITIATIVE LIST & TITLES --- */
        .initiative-list { 
            list-style: none; 
            padding: 0; 
            /* Grid layout for better organization */
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }
        .initiative-list li {
            margin-bottom: 0; /* Remove default list item margin */
        }
        .initiative-title {
            background-color: white;
            padding: 20px 25px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.07);
            /* This border color will be set dynamically below */
            border-left: 6px solid #ff7f50; 
            cursor: pointer;
            transition: all 0.3s ease;
            height: 100%; /* Ensure all items in the grid are same height */
            box-sizing: border-box;
        }
        .initiative-title:hover { 
            background-color: #fcfcfc; 
            border-left-color: #e65c00; 
            transform: translateY(-2px);
        }
        .initiative-title strong { 
            color: #003366; 
            font-size: 1.2rem; 
            font-weight: 600;
            display: block; /* Ensure title is on its own line */
            margin-bottom: 5px;
        }
        .data-structure-tag { 
            font-weight: 500; 
            color: #495057; 
            margin-top: 5px;
            background-color: #e9ecef; 
            padding: 5px 10px; 
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            display: inline-block;
            font-size: 0.85rem;
        }
        .sdg-tag {
            font-weight: 700;
            color: #007bff;
            background-color: #e3f2fd;
            padding: 5px 10px;
            border-radius: 4px;
            display: inline-block;
            margin-top: 10px;
            font-size: 0.8rem;
            border: 1px solid #007bff;
        }

        /* --- DETAIL CARD (The Algorithm Report) --- */
        .detail-card {
            /* Now placed outside the grid for full width presentation */
            background-color: #ffffff;
            border: 1px solid #ced4da;
            border-radius: 8px;
            padding: 30px;
            margin-top: 15px;
            margin-bottom: 40px;
            box-shadow: 0 6px 15px rgba(0,0,0,0.1);
            display: none; 
            grid-column: 1 / -1; /* Make detail card span entire width of the grid */
        }
        .detail-card h3 { 
            color: #212529; 
            border-bottom: 2px solid #adb5bd; 
            padding-bottom: 8px; 
            margin-top: 0; 
            font-size: 1.8rem;
            font-weight: 600;
        }
        .detail-card h4 { 
            color: #1a7e44; /* Dark Green for key sections */
            margin-top: 25px; 
            margin-bottom: 10px; 
            font-size: 1.2rem; 
            font-weight: 600;
        }
        .detail-card p, .detail-card li { 
            font-size: 1.0rem; 
            line-height: 1.7; 
            color: #495057;
        }
        
        /* --- CODE & DATA FORMATTING --- */
        pre {
            background-color: #343a40; /* Dark Gray Code Background */
            color: #e9ecef; /* Light Gray Code Text */
            padding: 18px;
            border-radius: 6px;
            overflow-x: auto;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.4;
            margin-top: 12px;
            white-space: pre-wrap;
        }
        .cpp-code {
            background-color: #000c1a; /* Darker Blue-Black for C++ */
            color: #c9e6ff; /* Lighter Blue for C++ */
            border-left: 5px solid #007bff;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: #f8f9fa;
        }
        th, td {
            border: 1px solid #dee2e6;
            padding: 12px;
            text-align: left;
            font-size: 0.95em;
        }
        th {
            background-color: #6c757d; /* Muted gray header */
            color: white;
            font-weight: 600;
        }
        .efficiency-badge {
            display: inline-block;
            background-color: #dc3545; 
            color: white;
            padding: 6px 12px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.9em;
            margin-top: 15px;
        }
        .reflection-block {
            background-color: #e9f0f7;
            border: 2px solid #0056b3;
            border-radius: 10px;
            padding: 30px;
            margin-top: 60px;
        }
        .reflection-block h2 {
            color: #001f40;
            font-size: 2.2rem;
            border-bottom: 3px dashed #adb5bd;
            padding-bottom: 10px;
        }
        .reflection-block p {
            font-size: 1.1rem;
            line-height: 1.8;
            color: #212529;
            margin-bottom: 20px;
        }
        .reflection-block ul {
            list-style: none;
            padding: 0;
        }
        .reflection-block li {
            background-color: #ffffff;
            margin-bottom: 10px;
            padding: 15px;
            border-left: 4px solid #1a7e44;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .reflection-block li strong {
            color: #0056b3;
        }


        /* --- CATEGORY COLOR ACCENTS --- */
        /* Port/Logistics (Initiatives 1-5): Cyan/Teal */
        .logistics-title { border-left-color: #17a2b8; } 
        /* Tourism/Food Truck (Initiatives 6-8): Coral/Orange */
        .tourism-title { border-left-color: #ff7f50; } 
        /* Public Services (Initiatives 9-11): Blue */
        .public-service-title { border-left-color: #007bff; } 
        /* Health/Wellness (Initiatives 12-14): Green */
        .health-title { border-left-color: #28a745; } 
        /* Gen-Z/Lifestyle (Initiatives 15-17): Vibrant Orange */
        .lifestyle-title { border-left-color: #fd7e14; } 

    </style>
    <script>
        function toggleDetails(id) {
            const element = document.getElementById(id);
            if (element.style.display === "grid") {
                element.style.display = "none";
            } else {
                // Hide all other open detail cards before showing the new one
                const allDetails = document.querySelectorAll('.detail-card');
                allDetails.forEach(card => {
                    if (card.id !== id) {
                        card.style.display = 'none';
                    }
                });
                // Display the selected card using grid to match the container's display style
                element.style.display = "grid"; 
            }
        }
    </script>
</head>
<body>

    <div class="header-container">
        <h1>Comprehensive Sustainable City Business Ideas</h1>
        <p>Strategic technology blueprint for diverse business initiatives, incorporating SDG alignment and detailed algorithmic analysis.</p>
    </div>

    <div class="main-content">
        
        <h2 class="category-heading">üö¢ Port Operations, IT & Maritime Logistics</h2>
        <ul class="initiative-list">
            
            <li class="initiative-title logistics-title" onclick="toggleDetails('details_1_1')">
                <strong>1. Multilingual BPO & IT Services Hub</strong>: <span class="data-structure-tag">Scheduling Algorithm (Round-Robin)</span>
                <span class="sdg-tag">SDG 8: Decent Work & Economic Growth</span>
            </li>
            <div id="details_1_1" class="detail-card">
                <h3>Problem Statement</h3>
                Fairly distribute incoming calls and tasks among a pool of multilingual agents to ensure fast and equitable service, preventing agent burnout or idle time.
                <h4>Solution Approach</h4>
                The **Round-Robin Scheduling** algorithm is chosen because it inherently guarantees **fairness and starvation-free execution**. By circulating the assignment pointer, it ensures that every agent receives an equal share of the workload over time, which directly contributes to better agent morale, reduced burnout, and consistent service quality. 
                <h4>Pseudo Code (Conceptual)</h4>
                <pre>
FUNCTION RoundRobin_Assign(AgentPool, NextIndex, Task):
    N = Size of AgentPool
    START_INDEX = NextIndex
    WHILE AgentPool[NextIndex] IS Busy:
        NextIndex = (NextIndex + 1) % N
        IF NextIndex == START_INDEX:
            RETURN "Wait Queue" // All agents busy
    
    Assign Task to AgentPool[NextIndex]
    NextIndex = (NextIndex + 1) % N // Move to the next agent
    RETURN NextIndex
</pre>
                <h4>C++ Pseudo-Code Implementation</h4>
                <pre class="cpp-code">
// Assumptions: AgentPool is a vector<Agent>, bool isBusy(int) is a check function
// Global or Class Member: static int next_agent_index = 0;

int assign_task_round_robin(const std::vector&lt;Agent&gt;& agentPool, Task& task) {
    int N = agentPool.size();
    if (N == 0) return -1;

    int start_index = next_agent_index;
    do {
        if (!agentPool[next_agent_index].isBusy()) {
            agentPool[next_agent_index].assign(task);
            return next_agent_index; // Task assigned

        }
        next_agent_index = (next_agent_index + 1) % N;
    } while (next_agent_index != start_index);

    return -2; // All agents busy, task goes to wait queue
}
</pre>
                <h4>Data Set (Input/Output Example)</h4>
                <table>
                    <thead><tr><th>Call Arrival</th><th>Agent Status</th><th>Next Agent Index</th><th>SDG Alignment</th></tr></thead>
                    <tbody>
                        <tr><td>Call 1</td><td>{F, F, F}</td><td>0</td><td rowspan="3">SDG 8 (Decent Work) ensures equitable task distribution among employees.</td></tr>
                        <tr><td>Call 2</td><td>{T, F, F}</td><td>1</td></tr>
                        <tr><td>Call 3</td><td>{T, T, F}</td><td>2</td></tr>
                    </tbody>
                </table>
                <span class="efficiency-badge">Efficiency: $O(N)$ (N = number of agents, worst case scan for availability), $O(1)$ average</span>
            </div>
            
            <li class="initiative-title logistics-title" onclick="toggleDetails('details_1_2')">
                <strong>2. Smart Port Security, Surveillance & Resource Allocation</strong>: <span class="data-structure-tag">Dijkstra + Stable Matching</span>
                <span class="sdg-tag">SDG 9: Industry, Innovation & Infrastructure</span>
            </li>
            <div id="details_1_2" class="detail-card">
                <h3>Problem Statement</h3>
                Assign the best-suited patrol units (responders) to security emergencies, minimizing response time (using shortest path) while considering responder capabilities and incident requirements (stable assignment).
                <h4>Solution Approach</h4>
                This crucial safety system combines two powerful paradigms. **Dijkstra's Algorithm** is applied first to find the globally optimal shortest path in terms of time, ensuring maximum efficiency in reaching the incident.  **Stable Matching (Gale-Shapley)** then uses these minimum times, along with responder/incident preference lists (skills vs. incident type), to find an assignment that minimizes the chances of a responder *preferring* a different, faster incident, thereby creating a reliable and non-blocking security plan.
                <h4>Pseudo Code (Stable Matching Component)</h4>
                <pre>
FUNCTION GaleShapley(Incidents, Responders):
    WHILE there is an Incident I that is free and hasn't proposed to everyone:
        R = I's highest ranked Responder (who hasn't been proposed to yet)
        IF R is free:
            (I, R) become matched
        ELSE IF R prefers I to its current partner I':
            I' becomes free
            (I, R) become matched
        ELSE:
            I proposes to its next preference
    RETURN Stable Matching
</pre>
                <h4>C++ Pseudo-Code Implementation (Dijkstra Component)</h4>
                <pre class="cpp-code">
// Uses Priority Queue (Min-Heap) for efficiency
// V = vertices (locations), E = edges (roads)

std::vector&lt;int&gt; dijkstra(const std::vector&lt;std::pair&lt;int, int&gt;&gt; adj[], int V, int start) {
    std::vector&lt;int&gt; dist(V, INT_MAX);
    std::priority_queue&lt;std::pair&lt;int, int&gt;, 
                        std::vector&lt;std::pair&lt;int, int&gt;&gt;, 
                        std::greater&lt;std::pair&lt;int, int&gt;&gt;&gt; pq;

    dist[start] = 0;
    pq.push({0, start}); // {distance, vertex}

    while (!pq.empty()) {
        int d = pq.top().first;
        int u = pq.top().second;
        pq.pop();

        if (d > dist[u]) continue;

        for (const auto& edge : adj[u]) {
            int v = edge.first;
            int weight = edge.second;
            if (dist[u] + weight &lt; dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
    return dist; // Returns min response time from start to all V
}
</pre>
                <h4>Data Set (Input/Output Example)</h4>
                <table>
                    <thead><tr><th>Incident ID</th><th>Required Skill</th><th>Responder Min Time (via Dijkstra)</th><th>SDG Alignment</th></tr></thead>
                    <tbody>
                        <tr><td>I-01 (Fire)</td><td>A/B certified</td><td>R1: 5 mins, R2: 8 mins</td><td rowspan="3">SDG 9 focuses on building resilient infrastructure and fostering innovation, which smart security systems achieve.</td></tr>
                        <tr><td>I-02 (HAZMAT)</td><td>HAZMAT certified</td><td>R1: 10 mins, R2: 3 mins</td></tr>
                    </tbody>
                </table>
                <span class="efficiency-badge">Efficiency: Dijkstra $O(E \log V)$; Stable Matching $O(N^2)$ (N = number of responders/incidents)</span>
            </div>
            
            <li class="initiative-title logistics-title" onclick="toggleDetails('details_1_3')">
                <strong>3. Port-Based Ship Repair & Maintenance Hub</strong>: <span class="data-structure-tag">Assembly-Line Scheduling (Dynamic Programming)</span>
                <span class="sdg-tag">SDG 9: Industry, Innovation & Infrastructure</span>
            </li>
            <div id="details_1_3" class="detail-card">
                <h3>Problem Statement</h3>
                Schedule multi-stage ship repair tasks across two or more parallel repair lines (workstations) to minimize the total completion time (makespan).
                <h4>Solution Approach</h4>
                **Assembly-Line Scheduling**, a core **Dynamic Programming** technique, is perfectly suited here. It avoids exhaustive search by identifying the optimal path to complete stage $j$ by referencing the minimum time achieved at stage $j-1$.  This approach systematically accounts for all time costs‚Äîwork time, entry/exit time, and inter-line transfer time‚Äîensuring the ship is repaired in the fastest possible manner, maximizing resource utilization.
                <h4>Pseudo Code (Conceptual)</h4>
                <pre>
FUNCTION MinTime_DP(Lines, Stages, EntryTime, ExitTime, TransferTime):
    // Time[i][j] = min time to finish stage j on line i
    Time[1][1] = EntryTime[1] + WorkTime[1][1]
    Time[2][1] = EntryTime[2] + WorkTime[2][1]

    FOR j = 2 TO Stages:
        Time[1][j] = min(Time[1][j-1], Time[2][j-1] + TransferTime[2] to [1]) + WorkTime[1][j]
        Time[2][j] = min(Time[2][j-1], Time[1][j-1] + TransferTime[1] to [2]) + WorkTime[2][j]

    RETURN min(Time[1][Stages] + ExitTime[1], Time[2][Stages] + ExitTime[2])
</pre>
                <h4>C++ Pseudo-Code Implementation</h4>
                <pre class="cpp-code">
// N is number of stages. WorkTime[i][j] and TransferTime[i][j] are given
int assembly_line_scheduling(int WorkTime[2][N], int TransferTime[2][N], 
                             int EntryTime[2], int ExitTime[2], int N) {
    
    int T1[N], T2[N]; // T[i] stores min time to finish stage i on line 1/2

    // Base Case for Stage 1 (j=0)
    T1[0] = EntryTime[0] + WorkTime[0][0]; 
    T2[0] = EntryTime[1] + WorkTime[1][0];

    // Fill the rest of the DP tables
    for (int j = 1; j < N; j++) {
        // Line 1
        T1[j] = std::min(T1[j-1] + WorkTime[0][j], 
                         T2[j-1] + TransferTime[1][j] + WorkTime[0][j]);

        // Line 2
        T2[j] = std::min(T2[j-1] + WorkTime[1][j], 
                         T1[j-1] + TransferTime[0][j] + WorkTime[1][j]);
    }

    // Final result
    return std::min(T1[N-1] + ExitTime[0], T2[N-1] + ExitTime[1]);
}
</pre>
                <h4>Data Set (Input/Output Example)</h4>
                <table>
                    <thead><tr><th>Stage (j)</th><th>Line 1 Time</th><th>Line 2 Time</th><th>SDG Alignment</th></tr></thead>
                    <tbody>
                        <tr><td>Hull Repair (1)</td><td>10 hrs</td><td>12 hrs</td><td rowspan="2">SDG 9 promotes industrialization and innovation by optimizing complex, resource-intensive processes like ship repair.</td></tr>
                        <tr><td>Engine Maint (2)</td><td>8 hrs</td><td>6 hrs</td></tr>
                    </tbody>
                </table>
                <span class="efficiency-badge">Efficiency: $O(N)$ (N = number of stages)</span>
            </div>

            <li class="initiative-title logistics-title" onclick="toggleDetails('details_1_4')">
                <strong>4. Harbor Logistics Truck Parking & Cargo Processing</strong>: <span class="data-structure-tag">FIFO + Greedy + Simulation</span>
                <span class="sdg-tag">SDG 12: Responsible Consumption & Production</span>
            </li>
            <div id="details_1_4" class="detail-card">
                <h3>Problem Statement</h3>
                Control the flow of trucks for arrival, parking, scanning, and weighing in the harbor to prevent congestion, managing queues while prioritizing high-value or fast-track cargo.
                <h4>Solution Approach</h4>
                This system uses a hybrid approach to balance fairness and throughput. The **FIFO Queue** maintains order for standard arrivals, while a **Greedy Strategy (Shortest Job First)** is implemented at the processing bottlenecks (scanner/weighing). This greedy prioritization ensures that resources are efficiently used by immediately processing the quickest tasks or highest-priority cargo, maximizing the flow of goods and minimizing truck idling time, thereby reducing emissions and congestion. 
                <h4>Pseudo Code (Greedy Selection at Bottleneck)</h4>
                <pre>
FUNCTION SelectNextTruck(ProcessingQueue):
    IF ProcessingQueue is EMPTY:
        RETURN NULL
        
    BestTruck = ProcessingQueue[0]
    // Greedy: Find highest priority/fastest processing truck
    FOR each Truck in ProcessingQueue:
        IF Truck.Priority == HIGH:
            RETURN Truck
        ELSE IF Truck.ProcessTime < BestTruck.ProcessTime:
            BestTruck = Truck
            
    RETURN BestTruck
</pre>
                <h4>C++ Pseudo-Code Implementation (SJF/Priority)</h4>
                <pre class="cpp-code">
struct Truck { int id; int priority; int process_time; };

Truck select_next_truck_greedy(std::vector&lt;Truck&gt;& processingQueue) {
    if (processingQueue.empty()) {
        return {-1, 0, 0}; // NULL truck
    }

    auto best_it = processingQueue.begin();

    for (auto it = processingQueue.begin(); it != processingQueue.end(); ++it) {
        // Priority 1: High priority always wins
        if (it->priority > best_it->priority) { 
            best_it = it;
        } 
        // Priority 2: Shortest Job First (SJF) among equal priorities
        else if (it->priority == best_it->priority && 
                 it->process_time < best_it->process_time) {
            best_it = it;
        }
    }

    Truck best_truck = *best_it;
    processingQueue.erase(best_it); // Remove the selected truck
    return best_truck;
}
</pre>
                <h4>Data Set (Input/Output Example)</h4>
                <table>
                    <thead><tr><th>Truck ID</th><th>Priority</th><th>Processing Time (mins)</th><th>SDG Alignment</th></tr></thead>
                    <tbody>
                        <tr><td>T-101</td><td>LOW</td><td>15</td><td rowspan="3">SDG 12 addresses waste reduction and efficient resource use by minimizing truck idling time and fuel consumption in the harbor.</td></tr>
                        <tr><td>T-Fast</td><td>HIGH</td><td>5</td></tr>
                    </tbody>
                </table>
                <span class="efficiency-badge">Efficiency: $O(N \log N)$ (N=queue size, due to sorting for greedy selection), $O(1)$ average</span>
            </div>
            
            <li class="initiative-title logistics-title" onclick="toggleDetails('details_1_5')">
                <strong>5. Port Infrastructure, Cold Storage & Industrial Facility Optimization</strong>: <span class="data-structure-tag">Dynamic Programming + Greedy + TSP</span>
                <span class="sdg-tag">SDG 13: Climate Action</span>
            </li>
            <div id="details_1_5" class="detail-card">
                <h3>Problem Statement</h3>
                Determine the optimal placement of new cold storage facilities within a large port area and establish the most cost-effective delivery routes for refrigerated cargo.
                <h4>Solution Approach</h4>
                The problem is modeled as the **Traveling Salesperson Problem (TSP)**, an NP-hard problem. Since finding the absolute optimum is too slow for large inputs, we choose a strategic hybrid: **Dynamic Programming with Bitmasking** for small clusters (exact route planning) and efficient **Greedy Heuristics** (like Nearest Neighbor or Clark-Wright) for larger networks.  Minimizing the total distance traveled by refrigerated trucks is crucial for reducing fuel consumption and associated carbon emissions.
                <h4>Pseudo Code (TSP - Dynamic Programming)</h4>
                <pre>
FUNCTION TSP_DP(StartNode, Mask):
    IF Mask == (1 << N) - 1: // All nodes visited
        RETURN Cost[StartNode][InitialNode]
    IF DP[StartNode][Mask] is Computed:
        RETURN DP[StartNode][Mask]
        
    MinCost = Infinity
    FOR NextNode = 0 TO N-1:
        IF (Mask & (1 << NextNode)) == 0: // If NextNode not visited
            NewMask = Mask | (1 << NextNode)
            Cost = Cost[StartNode][NextNode] + TSP_DP(NextNode, NewMask)
            MinCost = min(MinCost, Cost)
            
    DP[StartNode][Mask] = MinCost
    RETURN MinCost
</pre>
                <h4>C++ Pseudo-Code Implementation (TSP with Bitmasking)</h4>
                <pre class="cpp-code">
// Cost[N][N] is the distance matrix. N <= 20 for feasible DP.
// DP[1 << N][N] is the memoization table.
int N = 5; // Number of nodes (cold stores)
int DP[1 << 20][20];
int Cost[20][20];

int tsp_dp_solve(int mask, int pos) {
    if (mask == ((1 << N) - 1)) {
        return Cost[pos][0]; // Return to starting node (0)
    }
    if (DP[mask][pos] != -1) {
        return DP[mask][pos];
    }

    int min_cost = INT_MAX;
    for (int next = 0; next < N; next++) {
        // Check if the 'next' node has not been visited (bit is not set in mask)
        if ((mask & (1 << next)) == 0) {
            int new_mask = mask | (1 << next);
            int current_cost = Cost[pos][next] + tsp_dp_solve(new_mask, next);
            min_cost = std::min(min_cost, current_cost);
        }
    }

    return DP[mask][pos] = min_cost;
}

// Call with: tsp_dp_solve(1, 0) // Starting at node 0, with mask indicating node 0 visited
</pre>
                <h4>Data Set (Input/Output Example)</h4>
                <table>
                    <thead><tr><th>Location</th><th>Distance Matrix</th><th>Demand Zone</th><th>SDG Alignment</th></tr></thead>
                    <tbody>
                        <tr><td>5 Cold Stores (Nodes)</td><td>Cost[i][j] (Trucking cost)</td><td>High volume export/import areas</td><td rowspan="3">SDG 13 requires action to combat climate change, which is achieved here by minimizing fuel consumption through optimal route planning.</td></tr>
                    </tbody>
                </table>
                <span class="efficiency-badge">Efficiency: $O(N^2 \cdot 2^N)$ (TSP Dynamic Programming, exact solution)</span>
            </div>

        </ul>

        <h2 class="category-heading">üèñ Coastal Tourism, Events & Hospitality</h2>
        <ul class="initiative-list">
            
            <li class="initiative-title tourism-title" onclick="toggleDetails('details_2_1')">
                <strong>6. Beach Wedding & Events Hub</strong>: <span class="data-structure-tag">Job Scheduling + Resource Allocation</span>
                <span class="sdg-tag">SDG 8: Decent Work & Economic Growth</span>
            </li>
            <div id="details_2_1" class="detail-card">
                <h3>Problem Statement</h3>
                Schedule multiple events (jobs) in a multi-venue environment, ensuring no time overlaps while tracking limited resources (staff, equipment, power) required by each event.
                <h4>Solution Approach</h4>
                This is solved using the **Greedy Interval Scheduling** approach. By sorting all events by their **earliest finish time**, the algorithm greedily selects the next compatible event. This is proven to maximize the total number of events scheduled, which translates directly to maximizing venue utilization and economic output without scheduling conflicts. 
                <h4>Pseudo Code (Activity Selection/Interval Scheduling)</h4>
                <pre>
FUNCTION MaximizeEvents(Events, Resources):
    Events = SORT(Events, by_Finish_Time)
    
    LastFinishTime = 0
    FOR each Event E in Sorted Events:
        IF E.StartTime >= LastFinishTime AND Resources.CanAllocate(E):
            Schedule E
            LastFinishTime = E.FinishTime
            Resources.Allocate(E)
            
    RETURN ScheduledEvents
</pre>
                <h4>C++ Pseudo-Code Implementation</h4>
                <pre class="cpp-code">
struct Event { int start; int end; int staff_needed; };

// Custom comparator to sort by finish time
bool compareEvents(const Event& a, const Event& b) {
    return a.end < b.end;
}

std::vector&lt;Event&gt; max_events_greedy(std::vector&lt;Event&gt;& events, int total_staff) {
    std::sort(events.begin(), events.end(), compareEvents);

    std::vector&lt;Event&gt; scheduled_events;
    int last_finish_time = 0;
    int current_staff_used = 0;

    for (const auto& E : events) {
        if (E.start >= last_finish_time && 
            current_staff_used + E.staff_needed <= total_staff) {
            
            scheduled_events.push_back(E);
            last_finish_time = E.end;
            // For simplicity, this assumes staff is released immediately
            current_staff_used += E.staff_needed; 
            // More complex tracking needed for simultaneous events
        }
    }
    return scheduled_events;
}
</pre>
                <h4>Data Set (Input/Output Example)</h4>
                <table>
                    <thead><tr><th>Event</th><th>Start</th><th>End</th><th>Staff Needed</th><th>SDG Alignment</th></tr></thead>
                    <tbody>
                        <tr><td>A (Wedding)</td><td>9:00</td><td>12:00</td><td>8</td><td rowspan="2">SDG 8 focuses on maximizing productivity and full employment by efficiently utilizing venue capacity and maximizing event opportunities.</td></tr>
                        <tr><td>B (Party)</td><td>11:00</td><td>13:00</td><td>4</td></tr>
                    </tbody>
                </table>
                <span class="efficiency-badge">Efficiency: $O(N \log N)$ (due to initial sorting)</span>
            </div>
            
            <li class="initiative-title tourism-title" onclick="toggleDetails('details_2_2')">
                <strong>7. EV Bike + Water Sports Rental Management</strong>: <span class="data-structure-tag">Hash Tables + Priority Queues</span>
                <span class="sdg-tag">SDG 12: Responsible Consumption & Production</span>
            </li>
            <div id="details_2_2" class="detail-card">
                <h3>Problem Statement</h3>
                Track the status of every equipment piece instantly, manage return times, and prioritize equipment that needs charging or maintenance immediately.
                <h4>Solution Approach</h4>
                **Hash Tables** provide $O(1)$ average time complexity for real-time status lookup, which is essential for fast customer service. A **Min-Heap Priority Queue** is used to prioritize maintenance tasks based on battery level (lowest battery first).  This dual-structure system ensures operational speed and minimizes equipment downtime, maximizing the useful life and utilization of each rental asset.
                <h4>Pseudo Code (Priority Queue for Charging)</h4>
                <pre>
FUNCTION PrioritizeCharging(EquipmentQueue, EquipmentID, BatteryLevel):
    // Use min-heap where key is BatteryLevel
    EquipmentQueue.Insert(BatteryLevel, EquipmentID)
    
FUNCTION GetNextToCharge():
    RETURN EquipmentQueue.ExtractMin()
</pre>
                <h4>C++ Pseudo-Code Implementation</h4>
                <pre class="cpp-code">
// Hash Table for real-time status lookup
std::unordered_map&lt;int, std::string&gt; equipment_status; 

// Priority Queue (Min-Heap) for charging priority. 
// Stores {battery_level, equipment_id}. std::pair naturally sorts by first element.
std::priority_queue&lt;std::pair&lt;int, int&gt;, 
                    std::vector&lt;std::pair&lt;int, int&gt;&gt;, 
                    std::greater&lt;std::pair&lt;int, int&gt;&gt;&gt; charge_queue;

void update_charge_queue(int id, int battery_level) {
    // Note: C++ standard PQ doesn't support easy 'decrease key' (update)
    // Common solution is to insert the new value and ignore the old one when extracted
    charge_queue.push({battery_level, id}); 
}

int get_next_to_charge() {
    if (charge_queue.empty()) return -1;
    
    int id = charge_queue.top().second;
    charge_queue.pop();
    return id; // Returns ID of the equipment with the lowest battery level
}
</pre>
                <h4>Data Set (Input/Output Example)</h4>
                <table>
                    <thead><tr><th>ID (Key)</th><th>Battery Level</th><th>Status (Hash)</th><th>SDG Alignment</th></tr></thead>
                    <tbody>
                        <tr><td>Bike-05</td><td>15%</td><td>Rented by P1</td><td rowspan="3">SDG 12 promotes sustainable management and efficient use of natural resources, extending product life through timely maintenance and optimal charging.</td></tr>
                        <tr><td>JetSki-01</td><td>80%</td><td>Available</td></tr>
                    </tbody>
                </table>
                <span class="efficiency-badge">Efficiency: $O(1)$ (Hash Lookup), $O(\log N)$ (Priority Queue Operations)</span>
            </div>
            
            <li class="initiative-title tourism-title" onclick="toggleDetails('details_2_3')">
                <strong>8. Coastal Food Truck Fleet Logistics & Inventory Optimization (Combined 8 & 9)</strong>: <span class="data-structure-tag">VRP with Capacity Constraints (VRP-C)</span>
                <span class="sdg-tag">SDG 13: Climate Action</span>
            </li>
            <div id="details_2_3" class="detail-card">
                <h3>Problem Statement (Consolidated)</h3>
                Determine the optimal **inventory** to load onto each food truck (Knapsack/Bin Packing) and calculate the most **cost-effective route** for that truck to its assigned coastal zones, ensuring the truck capacity is never exceeded and total distance is minimized.
                <h4>Solution Approach</h4>
                Addressing this as the **Vehicle Routing Problem with Capacity Constraints (VRP-C)** allows for simultaneous route and inventory optimization. The **Clark-Wright Savings Algorithm** is the chosen heuristic because it quickly and effectively merges routes that yield the greatest cost savings, provided the capacity constraint of the truck is respected.  This methodology directly reduces fleet mileage, cutting fuel costs, delivery time, and carbon emissions.
                <h4>Pseudo Code (Clark-Wright VRP-C Heuristic)</h4>
                <pre>
FUNCTION ClarkWrightVRP_C(Depot, Customers, TruckCapacity):
    Compute all Savings S(i, j) = Dist(Depot, i) + Dist(Depot, j) - Dist(i, j)
    SORT Savings S(i, j) in decreasing order
    
    Start each Customer in its own route (Depot -> i -> Depot)
    
    FOR each Saving S(i, j) in sorted order:
        IF i and j are currently in different routes:
            TotalDemand = Demand(Route i) + Demand(Route j)
            
            IF TotalDemand < TruckCapacity:
                Merge Route i and Route j
                
    RETURN Final Optimized Routes (Inventory & Route Combined)
</pre>
                <h4>C++ Pseudo-Code Implementation (Savings Calculation)</h4>
                <pre class="cpp-code">
struct Saving { int i, j, value; };

// Custom comparator to sort savings in descending order
bool compareSavings(const Saving& a, const Saving& b) {
    return a.value > b.value;
}

// Assumes Dist[N][N] is the distance matrix (N = customers + depot)
// Node 0 is the Depot. Customers are 1 to N-1.
std::vector&lt;Saving&gt; compute_savings(int N, const int Dist[N][N]) {
    std::vector&lt;Saving&gt; savings;
    for (int i = 1; i < N; ++i) {
        for (int j = i + 1; j < N; ++j) {
            int s = Dist[0][i] + Dist[0][j] - Dist[i][j];
            savings.push_back({i, j, s});
        }
    }
    std::sort(savings.begin(), savings.end(), compareSavings);
    return savings;
}

// Merging logic (omitted for brevity, requires complex route data structure and capacity check)
</pre>
                <h4>Data Set (Input/Output Example)</h4>
                <table>
                    <thead><tr><th>Zone (Node)</th><th>Demand (Inventory Weight)</th><th>Distance to Depot</th><th>SDG Alignment</th></tr></thead>
                    <tbody>
                        <tr><td>Zone A (1)</td><td>70 kg</td><td>10 km</td><td rowspan="3">SDG 13 addresses climate change by reducing the carbon footprint of the fleet through minimized travel distance.</td></tr>
                        <tr><td>Zone B (2)</td><td>120 kg</td><td>15 km</td></tr>
                        <tr><td>Zone C (3)</td><td>40 kg</td><td>5 km</td></tr>
                    </tbody>
                </table>
                <span class="efficiency-badge">Efficiency: NP-hard (Exact VRP-C), Clark-Wright $O(N^2)$</span>
            </div>

        </ul>
        
        <h2 class="category-heading">üè¶ Public Services & Customer Management</h2>
        <ul class="initiative-list">
            
            <li class="initiative-title public-service-title" onclick="toggleDetails('details_3_1')">
                <strong>9. Customer Service & Public Service Queue Management</strong>: <span class="data-structure-tag">Round-Robin + Multi-Level Priority Queues</span>
                <span class="sdg-tag">SDG 16: Peace, Justice & Strong Institutions</span>
            </li>
            <div id="details_3_1" class="detail-card">
                <h3>Problem Statement</h3>
                Maintain fair queue processing (FIFO/Round-Robin) for standard citizens while ensuring emergency cases (medical, time-critical) are immediately processed by dedicated staff/counters.
                <h4>Solution Approach</h4>
                This system utilizes **Multi-Level Priority Queues** to achieve both **equity and urgency**. Standard requests are handled on a first-come, first-served basis for fairness, while emergency cases are placed in a Max-Heap Priority Queue.  The algorithm always checks the Max-Heap first, ensuring critical needs (Max Priority) are met immediately, a crucial requirement for responsive public services.
                <h4>Pseudo Code (Conceptual)</h4>
                <pre>
FUNCTION ProcessCustomer(EmergencyQueue, StandardQueue):
    IF EmergencyQueue IS NOT EMPTY:
        Customer = EmergencyQueue.PopMaxPriority()
        Dispatch to Emergency Counter
    ELSE:
        Customer = StandardQueue.RoundRobinPop()
        Dispatch to Standard Counter
</pre>
                <h4>C++ Pseudo-Code Implementation</h4>
                <pre class="cpp-code">
struct Customer { int id; int priority; };

// Max-Heap for Emergency Queue (priority = higher number is more critical)
// Default std::priority_queue is a Max-Heap
std::priority_queue&lt;std::pair&lt;int, int&gt;&gt; emergency_queue; // {priority, id}

// Standard Queue (FIFO, can use std::queue)
std::queue&lt;int&gt; standard_queue; 

int dispatch_next_customer() {
    if (!emergency_queue.empty()) {
        int id = emergency_queue.top().second;
        emergency_queue.pop();
        return id; // Emergency case
    } else if (!standard_queue.empty()) {
        int id = standard_queue.front();
        standard_queue.pop();
        return id; // Standard case (FIFO/Round Robin)
    }
    return -1; // No customers
}
</pre>
                <h4>Data Set (Input/Output Example)</h4>
                <table>
                    <thead><tr><th>Customer ID</th><th>Type</th><th>Priority</th><th>SDG Alignment</th></tr></thead>
                    <tbody>
                        <tr><td>C-101</td><td>Standard</td><td>1</td><td rowspan="3">SDG 16 focuses on effective, accountable, and inclusive institutions by ensuring equitable access and responsive service delivery.</td></tr>
                        <tr><td>C-Emer</td><td>Emergency</td><td>10</td></tr>
                    </tbody>
                </table>
                <span class="efficiency-badge">Efficiency: $O(\log N)$ (Emergency Pop), $O(1)$ (Standard Pop)</span>
            </div>
            
            <li class="initiative-title public-service-title" onclick="toggleDetails('details_3_2')">
                <strong>10. Fast Facility Lookup & Navigation System</strong>: <span class="data-structure-tag">Trie (Prefix Tree)</span>
                <span class="sdg-tag">SDG 9: Industry, Innovation & Infrastructure</span>
            </li>
            <div id="details_3_2" class="detail-card">
                <h3>Problem Statement</h3>
                Provide instant, prefix-based search and autocomplete functionality for internal navigation to rooms, counters, offices, or departments.
                <h4>Solution Approach</h4>
                The **Trie (Prefix Tree)** is chosen specifically for its unparalleled efficiency in prefix searching.  Unlike hash tables or binary trees, a Trie enables lookups and autocomplete suggestions in time proportional only to the length of the query ($O(L)$), regardless of the total number of items stored ($N$). This is essential for creating a responsive, high-speed, and intuitive navigation experience.
                <h4>Pseudo Code (Conceptual)</h4>
                <pre>
FUNCTION Insert(Trie, Word):
    CurrentNode = Root
    FOR each Char in Word:
        IF Char is NOT in CurrentNode.Children:
            Create New Node for Char
        CurrentNode = CurrentNode.Child[Char]
    CurrentNode.IsEndOfWord = True

FUNCTION SearchPrefix(Trie, Prefix):
    CurrentNode = Root
    FOR each Char in Prefix:
        CurrentNode = CurrentNode.Child[Char]
        IF CurrentNode is NULL:
            RETURN Empty List
    RETURN All Words under CurrentNode subtree
</pre>
                <h4>C++ Pseudo-Code Implementation</h4>
                <pre class="cpp-code">
#define ALPHABET_SIZE 26

struct TrieNode {
    TrieNode* children[ALPHABET_SIZE];
    bool isEndOfWord;

    TrieNode() : isEndOfWord(false) {
        for (int i = 0; i < ALPHABET_SIZE; i++) {
            children[i] = nullptr;
        }
    }
};

void insert_word(TrieNode* root, const std::string& key) {
    TrieNode* curr = root;
    for (char c : key) {
        int index = c - 'a'; // Assuming lowercase English letters
        if (!curr->children[index]) {
            curr->children[index] = new TrieNode();
        }
        curr = curr->children[index];
    }
    curr->isEndOfWord = true;
}
// Helper functions for search and autocomplete are omitted for brevity.
</pre>
                <h4>Data Set (Input/Output Example)</h4>
                <table>
                    <thead><tr><th>Stored Words</th><th>Input Prefix</th><th>Trie Traversal</th><th>SDG Alignment</th></tr></thead>
                    <tbody>
                        <tr><td>Accounts, Audit, Admin</td><td>A</td><td>Root -> A</td><td rowspan="2">SDG 9 promotes technological innovation and adoption in public services to increase efficiency and accessibility.</td></tr>
                        <tr><td>-</td><td>Au</td><td>Root -> A -> u</td></tr>
                    </tbody>
                </table>
                <span class="efficiency-badge">Efficiency: $O(L)$ (L = length of prefix/word, regardless of total words N)</span>
            </div>
            
            <li class="initiative-title public-service-title" onclick="toggleDetails('details_3_3')">
                <strong>11. Digital Advertising & Events Hub</strong>: <span class="data-structure-tag">Interval Scheduling + Constraint Satisfaction</span>
                <span class="sdg-tag">SDG 8: Decent Work & Economic Growth</span>
            </li>
            <div id="details_3_3" class="detail-card">
                <h3>Problem Statement</h3>
                Schedule digital advertisements and events (intervals) within a fixed timeline without time overlaps, maximizing the total value generated, subject to placement rules (constraints).
                <h4>Solution Approach</h4>
                This is a classic optimization problem solved using a **Greedy Algorithm** for the **Interval Scheduling Problem**. By sorting all potential advertisements or events by their **finish time**, the algorithm makes the locally optimal choice at each step (selecting the event that finishes earliest).  This strategy is mathematically proven to yield the globally maximum number of non-overlapping activities, maximizing the utilization and revenue potential of the digital platform.
                <h4>Pseudo Code (Interval Scheduling)</h4>
                <pre>
FUNCTION MaximizeValue(Intervals, Constraints):
    Intervals = SORT(Intervals, by_Finish_Time)
    
    ScheduledSet = Empty
    LastFinishTime = 0
    FOR each Interval I in Sorted Intervals:
        IF I.StartTime >= LastFinishTime AND CheckConstraints(I, ScheduledSet):
            Add I to ScheduledSet
            LastFinishTime = I.FinishTime
            
    RETURN ScheduledSet
</pre>
                <h4>C++ Pseudo-Code Implementation</h4>
                <pre class="cpp-code">
struct Interval { int start; int end; std::string name; };

// Custom comparator to sort intervals by end time
bool compareIntervals(const Interval& a, const Interval& b) {
    return a.end < b.end;
}

std::vector&lt;Interval&gt; interval_scheduling_greedy(std::vector&lt;Interval&gt;& intervals) {
    std::sort(intervals.begin(), intervals.end(), compareIntervals);

    std::vector&lt;Interval&gt; scheduled;
    int last_finish_time = 0;

    for (const auto& I : intervals) {
        if (I.start >= last_finish_time) {
            // Check for additional constraints (omitted for simplicity)
            scheduled.push_back(I);
            last_finish_time = I.end;
        }
    }
    return scheduled;
}
</pre>
                <h4>Data Set (Input/Output Example)</h4>
                <table>
                    <thead><tr><th>Ad/Event</th><th>Start Time</th><th>End Time</th><th>SDG Alignment</th></tr></thead>
                    <tbody>
                        <tr><td>Ad A</td><td>10:00</td><td>10:30</td><td rowspan="2">SDG 8 promotes sustained economic growth by ensuring the efficient and optimal use of digital advertising resources to maximize revenue and economic activity.</td></tr>
                        <tr><td>Ad B</td><td>10:15</td><td>10:45</td></tr>
                    </tbody>
                </table>
                <span class="efficiency-badge">Efficiency: $O(N \log N)$ (due to initial sorting)</span>
            </div>

        </ul>
        
        <h2 class="category-heading">üßò Health & Wellness</h2>
        <ul class="initiative-list">

            <li class="initiative-title health-title" onclick="toggleDetails('details_4_1')">
                <strong>12. Coastal Massage, Spa & Appointment Booking</strong>: <span class="data-structure-tag">Segment Trees + Interval Queries</span>
                <span class="sdg-tag">SDG 3: Good Health & Well-being</span>
            </li>
            <div id="details_4_1" class="detail-card">
                <h3>Problem Statement</h3>
                Efficiently check for availability or density of spa/massage appointments over time intervals (e.g., how many bookings are there between 2 PM and 4 PM across all treatment rooms).
                <h4>Solution Approach</h4>
                A **Segment Tree** with **Lazy Propagation** is the most efficient choice for handling large volumes of range-based data.  Booking an appointment is treated as a range update on the time axis, and checking availability for a specific time window is a range query. This structure guarantees $O(\log N)$ time complexity for both operations, ensuring near-instantaneous query responses even with a fully booked schedule.
                <h4>Pseudo Code (Segment Tree - Lazy Propagation for Range Update)</h4>
                <pre>
FUNCTION UpdateRange(Node, StartTime, EndTime, RangeToUpdate, Value):
    // Standard Segment Tree Range Update with Lazy Propagation
    IF Node.Range is entirely within RangeToUpdate:
        Node.Count += Value
        IF NOT Leaf: Node.Lazy += Value
        RETURN

    Propagate Lazy Value Down
    UpdateRange(Node.Left, ...)
    UpdateRange(Node.Right, ...)
    Node.Count = Node.Left.Count + Node.Right.Count

FUNCTION QueryPoint(Node, TimePoint):
    // Find the total count for a specific minute/slot
    // Traverse down, accumulating lazy/actual counts
</pre>
                <h4>C++ Pseudo-Code Implementation (Conceptual Segment Tree Structure)</h4>
                <pre class="cpp-code">
// Assuming N is the max time point (e.g., 1440 minutes for a day)
const int N = 1440; 
int tree[4 * N]; // Segment Tree array (4N size)
int lazy[4 * N]; // Lazy Propagation array

void push(int node, int start, int end) {
    if (lazy[node] != 0) {
        tree[node] += lazy[node] * (end - start + 1); // Apply lazy value
        if (start != end) {
            lazy[2 * node] += lazy[node]; // Propagate to children
            lazy[2 * node + 1] += lazy[node];
        }
        lazy[node] = 0; // Reset lazy value
    }
}

void update_range(int node, int start, int end, int l, int r, int val) {
    push(node, start, end);
    if (start > end || start > r || end < l) return; // Out of range
    if (l <= start && end <= r) { // Current segment completely within range
        lazy[node] += val;
        push(node, start, end);
        return;
    }
    int mid = (start + end) / 2;
    update_range(2 * node, start, mid, l, r, val);
    update_range(2 * node + 1, mid + 1, end, l, r, val);
    tree[node] = tree[2 * node] + tree[2 * node + 1];
}
</pre>
                <h4>Data Set (Input/Output Example)</h4>
                <table>
                    <thead><tr><th>Time Slot</th><th>Action</th><th>Rooms</th><th>SDG Alignment</th></tr></thead>
                    <tbody>
                        <tr><td>2:00 PM - 3:00 PM</td><td>Book</td><td>Room 1</td><td rowspan="2">SDG 3 promotes well-being for all ages by ensuring streamlined access to health and wellness services through efficient scheduling.</td></tr>
                        <tr><td>Query 2:30 PM</td><td>Check</td><td>-</td></tr>
                    </tbody>
                </table>
                <span class="efficiency-badge">Efficiency: $O(\log N)$ (for Range Update and Range/Point Query)</span>
            </div>

            <li class="initiative-title health-title" onclick="toggleDetails('details_4_2')">
                <strong>13. Mental Health & Rehabilitation Hub</strong>: <span class="data-structure-tag">K-Means Clustering</span>
                <span class="sdg-tag">SDG 3: Good Health & Well-being</span>
            </li>
            <div id="details_4_2" class="detail-card">
                <h3>Problem Statement</h3>
                Group patients into compatible therapy clusters (groups) based on their profiles, needs, and recovery stage, optimizing group therapy effectiveness.
                <h4>Solution Approach</h4>
                The **K-Means Clustering Algorithm** is an unsupervised machine learning method that partitions the patient dataset into *K* distinct clusters.  This mathematical approach minimizes the variance (distance) within each cluster, ensuring that patients grouped together have the highest degree of similarity in their therapeutic needs, leading to optimized peer support and more effective group therapy outcomes.
                <h4>Pseudo Code (K-Means)</h4>
                <pre>
FUNCTION KMeans(DataPoints, K):
    Initialize K Centroids (randomly or smartly)
    
    REPEAT:
        // Assignment Step
        FOR each DataPoint P:
            Assign P to the nearest Centroid (Cluster)
        
        // Update Step
        FOR each Cluster C:
            New Centroid = Mean of all Points in C
            
    UNTIL Centroids do not change significantly
    RETURN Final Clusters
</pre>
                <h4>C++ Pseudo-Code Implementation (Conceptual Step)</h4>
                <pre class="cpp-code">
struct Patient { double features[D]; int cluster_id; };
struct Centroid { double position[D]; };

// Function to calculate Euclidean distance in D dimensions
double euclidean_distance(const Patient& p, const Centroid& c, int D) {
    double sum = 0.0;
    for (int i = 0; i < D; ++i) {
        sum += std::pow(p.features[i] - c.position[i], 2);
    }
    return std::sqrt(sum);
}

void assignment_step(std::vector&lt;Patient&gt;& patients, 
                     const std::vector&lt;Centroid&gt;& centroids, int K, int D) {
    for (auto& p : patients) {
        double min_dist = std::numeric_limits&lt;double&gt;::max();
        for (int k = 0; k < K; ++k) {
            double dist = euclidean_distance(p, centroids[k], D);
            if (dist < min_dist) {
                min_dist = dist;
                p.cluster_id = k;
            }
        }
    }
}
// Update step involves computing the mean of all patients in a cluster
</pre>
                <h4>Data Set (Input/Output Example)</h4>
                <table>
                    <thead><tr><th>Patient Feature</th><th>Value (Normalized)</th><th>SDG Alignment</th></tr></thead>
                    <tbody>
                        <tr><td>Symptom Score (x)</td><td>0.8</td><td rowspan="2">SDG 3 aims to promote mental health and well-being by facilitating evidence-based, targeted group therapy sessions based on patient needs.</td></tr>
                        <tr><td>Support Score (y)</td><td>0.2</td></tr>
                    </tbody>
                </table>
                <span class="efficiency-badge">Efficiency: $O(T \cdot K \cdot N \cdot D)$ (T=iterations, K=clusters, N=patients, D=dimensions)</span>
            </div>

            <li class="initiative-title health-title" onclick="toggleDetails('details_4_3')">
                <strong>14. Marine Equipment Manufacturing Unit</strong>: <span class="data-structure-tag">Greedy Job Sequencing</span>
                <span class="sdg-tag">SDG 9: Industry, Innovation & Infrastructure</span>
            </li>
            <div id="details_4_3" class="detail-card">
                <h3>Problem Statement</h3>
                Schedule the execution of various machine jobs (tasks) to maximize production (value/profit) and minimize idle time, where each job has a deadline and an associated profit.
                <h4>Solution Approach</h4>
                The problem is a maximization problem solved by the **Greedy Job Sequencing Algorithm with Deadlines**. The algorithm's greedy choice is to **sort all jobs by profit in descending order**. It then schedules the highest-profit job into the latest possible time slot before its deadline.  This strategy is proven to yield the globally maximum possible profit, efficiently maximizing production output.
                <h4>Pseudo Code (Conceptual)</h4>
                <pre>
FUNCTION JobSequencing(Jobs):
    Jobs = SORT(Jobs, by_Profit_Descending) // Greedy choice
    MaxDeadline = max(Jobs.Deadline)
    TimeSlots = Array[1..MaxDeadline] initialized to False
    
    ScheduledJobs = Empty
    FOR each Job J in Sorted Jobs:
        // Find latest free slot before J's deadline
        FOR t = min(J.Deadline, MaxDeadline) DOWNTO 1:
            IF TimeSlots[t] is FREE:
                Schedule J at Time t
                TimeSlots[t] = TRUE
                Add J to ScheduledJobs
                BREAK
                
    RETURN TotalProfit(ScheduledJobs)
</pre>
                <h4>C++ Pseudo-Code Implementation</h4>
                <pre class="cpp-code">
struct Job { int id; int deadline; int profit; };

// Custom comparator to sort jobs by profit in descending order
bool compareJobs(const Job& a, const Job& b) {
    return a.profit > b.profit;
}

int job_sequencing_greedy(std::vector&lt;Job&gt;& jobs, int max_deadline) {
    std::sort(jobs.begin(), jobs.end(), compareJobs);

    std::vector&lt;bool&gt; time_slots(max_deadline + 1, false);
    int total_profit = 0;

    for (const auto& J : jobs) {
        // Find the latest free slot before or at the deadline
        for (int t = std::min(max_deadline, J.deadline); t >= 1; --t) {
            if (!time_slots[t]) {
                time_slots[t] = true; // Schedule the job
                total_profit += J.profit;
                break;
            }
        }
    }
    return total_profit;
}
</pre>
                <h4>Data Set (Input/Output Example)</h4>
                <table>
                    <thead><tr><th>Job ID</th><th>Deadline</th><th>Profit</th><th>SDG Alignment</th></tr></thead>
                    <tbody>
                        <tr><td>J-A</td><td>2 days</td><td>100</td><td rowspan="2">SDG 9 emphasizes sustainable industrialization and innovation by maximizing production output from limited machine time (non-renewable resource).</td></tr>
                        <tr><td>J-B</td><td>1 day</td><td>200</td></tr>
                    </tbody>
                </table>
                <span class="efficiency-badge">Efficiency: $O(N \log N + N \cdot M)$ (N=jobs, M=max deadline)</span>
            </div>

        </ul>
        
        <h2 class="category-heading">üå∏ Gen-Z Lifestyle & Wellness Brands</h2>
        <ul class="initiative-list">

            <li class="initiative-title lifestyle-title" onclick="toggleDetails('details_5_1')">
                <strong>15. TopFitness Club - Trainer/Slot Scheduling</strong>: <span class="data-structure-tag">Greedy + Priority Queues</span>
                <span class="sdg-tag">SDG 3: Good Health & Well-being</span>
            </li>
            <div id="details_5_1" class="detail-card">
                <h3>Problem Statement</h3>
                Schedule trainers and workout slots to maximize customer satisfaction/revenue, using a priority queue to manage available resources (trainers).
                <h4>Solution Approach</h4>
                A combination of **Greedy** choice (sort high-value sessions first) and a **Min-Heap Priority Queue** for resource allocation is used. The Min-Heap stores the earliest time a trainer becomes free.  By assigning the session to the trainer who is free earliest, we ensure optimal trainer utilization and maximize the number of sessions that can be held throughout the day, thus maximizing revenue and service availability.
                <h4>Pseudo Code (Min-Heap for Trainer Availability)</h4>
                <pre>
FUNCTION ScheduleTrainers(Sessions, Trainers):
    Sessions = SORT(Sessions, by_Value_Descending) // Greedy
    PQ = Min-Heap of {Trainer Finish Time}
    
    FOR each Trainer T:
        PQ.Insert(T.CurrentFinishTime) // Initialize to 0
        
    FOR each Session S in Sorted Sessions:
        EarliestFreeTime = PQ.ExtractMin()
        IF S.StartTime >= EarliestFreeTime:
            // Assign session to this trainer
            NewFinishTime = S.FinishTime
            PQ.Insert(NewFinishTime)
        ELSE:
            // Trainer not free, re-insert original time and skip session
            PQ.Insert(EarliestFreeTime)
</pre>
                <h4>C++ Pseudo-Code Implementation</h4>
                <pre class="cpp-code">
struct Session { int start; int end; int value; };
// Custom comparator for greedy choice
bool compareSessions(const Session& a, const Session& b) {
    return a.value > b.value;
}

// Min-Heap stores the time when the trainer becomes free
std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; trainer_free_time_pq; 

void initialize_trainers(int num_trainers) {
    for (int i = 0; i < num_trainers; ++i) {
        trainer_free_time_pq.push(0); // All trainers free at time 0
    }
}

void schedule_session(const std::vector&lt;Session&gt;& sessions) {
    std::vector&lt;Session&gt; sorted_sessions = sessions;
    std::sort(sorted_sessions.begin(), sorted_sessions.end(), compareSessions);

    for (const auto& S : sorted_sessions) {
        int earliest_free = trainer_free_time_pq.top();
        trainer_free_time_pq.pop();

        if (S.start >= earliest_free) {
            // Trainer is free in time for the session
            trainer_free_time_pq.push(S.end); 
        } else {
            // Cannot assign, put the trainer's original free time back
            trainer_free_time_pq.push(earliest_free); 
        }
    }
    // Final PQ state holds the finish times for all trainers.
}
</pre>
                <h4>Data Set (Input/Output Example)</h4>
                <table>
                    <thead><tr><th>Session ID</th><th>Start/End</th><th>Value/Demand</th><th>SDG Alignment</th></tr></thead>
                    <tbody>
                        <tr><td>S-Yoga</td><td>9:00-10:00</td><td>150 (High)</td><td rowspan="2">SDG 3 promotes healthy lives and well-being by maximizing access to fitness services through efficient scheduling of limited trainers.</td></tr>
                        <tr><td>S-Spin</td><td>9:30-10:30</td><td>80 (Medium)</td></tr>
                    </tbody>
                </table>
                <span class="efficiency-badge">Efficiency: $O(N \log N)$ (N=sessions, due to sorting and PQ operations)</span>
            </div>

            <li class="initiative-title lifestyle-title" onclick="toggleDetails('details_5_2')">
                <strong>16. Glow Beauty & Nail Art Studio</strong>: <span class="data-structure-tag">Interval Scheduling</span>
                <span class="sdg-tag">SDG 5: Gender Equality</span>
            </li>
            <div id="details_5_2" class="detail-card">
                <h3>Problem Statement</h3>
                Efficiently manage the schedules of multiple beauty artists (resources) and various services (jobs) to maximize the total number of appointments and revenue without overlaps.
                <h4>Solution Approach</h4>
                This is the multi-resource version of the **Interval Scheduling Problem**. By sorting all services by their **earliest finish time**, we greedily select the service and assign it to the first available artist of the required type.  This strategy ensures that artist time is never wasted, maximizing the number of clients served, which is vital for the small business economy and staff utilization.
                <h4>Pseudo Code (Multi-Resource Interval Scheduling)</h4>
                <pre>
FUNCTION ScheduleStudio(Services, Artists):
    Services = SORT(Services, by_Finish_Time)
    
    ArtistFinishTime = Map {ArtistID: LastFinishTime}
    FOR each Service S in Sorted Services:
        Find Artist A who is free earliest, where S.StartTime >= A.LastFinishTime
        
        IF Artist A is Found:
            Schedule S to A
            ArtistFinishTime[A] = S.FinishTime
            
    RETURN TotalScheduledServices
</pre>
                <h4>C++ Pseudo-Code Implementation (Conceptual)</h4>
                <pre class="cpp-code">
struct Service { int start; int end; std::string artist_type; };

// Custom comparator to sort services by end time
bool compareServices(const Service& a, const Service& b) {
    return a.end < b.end;
}

// Map stores the finish time for each artist of a specific type
std::unordered_map&lt;std::string, std::vector&lt;int&gt;&gt; artist_free_times; 

void multi_resource_scheduling(std::vector&lt;Service&gt;& services) {
    std::sort(services.begin(), services.end(), compareServices);

    for (const auto& S : services) {
        if (artist_free_times.find(S.artist_type) == artist_free_times.end()) {
            // Initialize artist type pool if not present (simple case)
            artist_free_times[S.artist_type].push_back(0); 
        }
        
        // Find the artist of the required type who is free earliest
        int best_artist_index = -1;
        int earliest_free_time = std::numeric_limits&lt;int&gt;::max();

        for(size_t i = 0; i < artist_free_times[S.artist_type].size(); ++i) {
            if (artist_free_times[S.artist_type][i] < earliest_free_time) {
                earliest_free_time = artist_free_times[S.artist_type][i];
                best_artist_index = i;
            }
        }
        
        // Assign if feasible
        if (S.start >= earliest_free_time && best_artist_index != -1) {
            artist_free_times[S.artist_type][best_artist_index] = S.end;
        }
    }
}
</pre>
                <h4>Data Set (Input/Output Example)</h4>
                <table>
                    <thead><tr><th>Service</th><th>Start/End</th><th>Artist Type</th><th>SDG Alignment</th></tr></thead>
                    <tbody>
                        <tr><td>Nail Art</td><td>11:00-12:00</td><td>Nail Artist</td><td rowspan="2">SDG 5 promotes gender equality by supporting female-dominated service businesses to optimize their efficiency and economic viability.</td></tr>
                        <tr><td>Massage</td><td>11:30-12:30</td><td>Masseuse</td></tr>
                    </tbody>
                </table>
                <span class="efficiency-badge">Efficiency: $O(N \log N + N \cdot M)$ (N=services, M=artists)</span>
            </div>

            <li class="initiative-title lifestyle-title" onclick="toggleDetails('details_5_3')">
                <strong>17. Sip & Sculpt Caf√©</strong>: <span class="data-structure-tag">Greedy + Queue-Based Order Management</span>
                <span class="sdg-tag">SDG 12: Responsible Consumption & Production</span>
            </li>
            <div id="details_5_3" class="detail-card">
                <h3>Problem Statement</h3>
                Control the flow of healthy caf√© orders, prioritizing those that require the quickest preparation (Greedy choice) to maximize throughput during peak hours, while still managing the main customer flow (Queue).
                <h4>Solution Approach</h4>
                This system applies the **Shortest Job First (SJF) Greedy** heuristic to the queue of prepared orders.  By prioritizing the orders with the minimum preparation time, the total waiting time for all customers is minimized (proven optimal for minimizing average waiting time). This maximizes the throughput of the kitchen staff and reduces the chance of food waste due to long queues or delayed service.
                <h4>Pseudo Code (Greedy Shortest Job First)</h4>
                <pre>
FUNCTION DispatchNextOrder(OrderQueue):
    IF OrderQueue is EMPTY: RETURN NULL
    
    // Greedy choice: Find order with Minimum Preparation Time
    ShortestTime = Infinity
    BestOrder = NULL
    
    FOR each Order O in OrderQueue:
        IF O.PreparationTime < ShortestTime:
            ShortestTime = O.PreparationTime
            BestOrder = O
            
    Remove BestOrder from Queue
    RETURN BestOrder
</pre>
                <h4>C++ Pseudo-Code Implementation</h4>
                <pre class="cpp-code">
struct Order { int id; int prep_time; };

Order dispatch_next_order_sjf(std::vector&lt;Order&gt;& orderQueue) {
    if (orderQueue.empty()) {
        return {-1, 0}; // NULL order
    }

    auto best_it = orderQueue.begin();
    int shortest_time = best_it->prep_time;

    for (auto it = orderQueue.begin(); it != orderQueue.end(); ++it) {
        if (it->prep_time < shortest_time) {
            shortest_time = it->prep_time;
            best_it = it;
        }
    }

    Order best_order = *best_it;
    orderQueue.erase(best_it); // Remove the selected order
    return best_order;
}
</pre>
                <h4>Data Set (Input/Output Example)</h4>
                <table>
                    <thead><tr><th>Order ID</th><th>Prep Time (mins)</th><th>Customer Arrived</th><th>SDG Alignment</th></tr></thead>
                    <tbody>
                        <tr><td>O-Latte</td><td>2</td><td>1st</td><td rowspan="2">SDG 12 emphasizes sustainable consumption by reducing wait times and minimizing operational waste through efficient, high-throughput service.</td></tr>
                        <tr><td>O-Bowl</td><td>10</td><td>2nd</td></tr>
                    </tbody>
                </table>
                <span class="efficiency-badge">Efficiency: $O(N)$ (N=orders in queue, for searching the shortest job)</span>
            </div>

        </ul>
        
        <div class="reflection-block">
            <h2>üìù Course Reflection: Design and Analysis of Algorithms</h2>
            <p>The study of the Design and Analysis of Algorithms has provided a robust framework for structured problem-solving, moving beyond functional code to focus on efficiency and scalability. The core learnings can be summarized as follows:</p>
            
            <ul>
                <li><strong>Systematic Problem Modeling:</strong> The course provided the critical skill to abstract real-world business challenges (like routing, scheduling, and resource allocation) into classical, solvable computational models (like TSP, Interval Scheduling, and VRP).</li>
                <li><strong>Mastery of Efficiency Metrics:</strong> A deep understanding of Big $O$ notation transformed solution evaluation. This allows for pragmatic choices between computationally expensive, optimal solutions (Dynamic Programming, TSP exact) and efficient, acceptable approximations (Greedy Heuristics, Clark-Wright) based on input size and business constraints.</li>
                <li><strong>The Paradigm Toolkit:</strong> Gaining proficiency in key algorithmic paradigms‚Äî**Greedy** (for optimal local choices), **Dynamic Programming** (for overlapping subproblems), and **Graph Algorithms** (for connectivity/paths)‚Äîprovides a comprehensive toolkit for designing truly performant software systems.</li>
                <li><strong>Data Structure Selection as the Foundation:</strong> Recognizing that the right data structure is the key to algorithmic performance (e.g., $O(1)$ lookup with Hash Tables, $O(\log N)$ range query with Segment Trees) is the most valuable takeaway, allowing for the construction of highly responsive and scalable architectures.</li>
            </ul>
        </div>

    </div>

</body>
</html>
